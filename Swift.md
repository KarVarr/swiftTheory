<h1>Swift</h1>

Оглавление:

- [Основы](#основы)
- [Базовые операторы](#базовые-операторы)
- [Хештруемые и сопоставимые данные](#хештруемые-и-сопоставимые-данные)
- [Управление потоком](#управление-потоком)
- [Регулярные выражения - Regex](#регулярные-выражения)
- [Функции](#функции)
- [Замыкание](#замыкание)
- [Перечисления](#перечисления)
- [Классы и структуры ](#классы-и-структуры )
- [Свойства](#свойства)
- [Методы](#методы)
- [Опциональные значения](#опциональные-значения)
- [ООП](#ооп)
- [Наследование](#наследование)
- [Инициализация](#инициализация)
- [Деинициализация](#деинициализация)
- [Обработка ошибок](#обработка-ошибок)
- [Расширения](#расширения)
- [Протоколы](#протоколы)
- [Дженерики](#дженерики)
- [ARC](#arc)
- [Тип памяти](#тип-памяти)
- [Делегирование](#делегирование)
- [Тайпкастинг](#тайпкастинг)
- [Контроль доступа](#контроль-доступа)
- [Singleton](#singleton)
- [Менеджеры зависимостей](#менеджеры-зависимостей)
- [Singleton](#singleton)
- [Жизненный цикл приложения](#жизненный-цикл-приложения)
- [Жизненный цикл ViewController](#жизненный-цикл-viewController)
- [Императивный Декларативный](#императивный-декларативны)
- [GCD задачи](#gcd-задачи)
- [User Defaults](#user-defaults)
- [Size Class](#size-class)
- [Singleton](#singleton)
- [Singleton](#singleton)
- [Singleton](#singleton)


## Основы
<span style="color: blue;">Синий текст</span>

<span style="background-color: yellow;">Фон текста желтого цвета</span>
Можно обозначать переменные или константы в один ряд через запятую со значениями. Так же можно обозначать имена переменных в один ряд через запятую без значения, только указав тип в конце. 

    var x = 0.0, y = 0.0, z = 0.0
    var red, green, blue: Double

    
Имена констант и переменных не могут содержать пробелы, математические символы, стрелки, так же не могут начинаться с цифр.
Если вам нужно объявить константу или переменную тем же именем, что и зарезервированное слово Swift, то вы можете воспользоваться обратными кавычками (`) написанными вокруг этого слова. 

    let `var` = 44


    
$${\color{orange}print()}$$
По умолчанию функция заканчивает вывод символом переноса строки. Чтобы вывести в консоль значения без переноса на новую строку, вам нужно указать пустую строку в параметре terminator, например,

    print(someValue, terminator: "")

$${\color{orange}Различие \space между \space Double \space и \space Float}$$
* Double - представляет собой 64-битное число с плавающей точкой. Используйте его когда число с плавающей точкой должно быть очень большим или чрезвычайно точным
* Float - представляет собой 32-битное число с плавающей точкой. Используйте его, когда значение не нуждается в 64-битной точности.
  
$${\color{orange}Псевдонимы \space типов \space typealias}$$
Псевдонимы типов задают альтернативное имя для существующего типа. Можно задать псевдоним типа с помощью ключевого слова typealias.
Псевдонимы типов полезны, когда вы хотите обратиться к существующему типу по имени, которое больше подходит по контексту, например, когда вы работаете с данными определенного размера из внешнего источника:

    typealias AudioSample = UInt16

    
$${\color{orange}Отладка \space с \space помощью \space утверждений}$$

    assert(_:_:file:line:).
    let age = -3
    assert(age >= 0, "Возраст человека не может быть меньше нуля")
    
это приведет к вызову утверждения, потому что age >= 0, а указанное значение < 0.
Вызывает runtime ошибку и приложение останавливается.

---

## Базовые операторы 
Операторы есть трех видов - унарный, бинарный и тернарный.
* Унарный тот который стоит возле числа слева, например -4(минус четыре). Или восклицательный знак после буквы, например а!.
* Бинарные операторы это те у которых значения стоят слева и справа, например знак равенства = (имя переменной и его значение). Или арифметические операторы между двумя числами 10 + 10.
* Тернарный условный оператор один, он сокращает запись сравнения if else.

        let age = 35
        age > 18 ? "Можешь пить пиво" : "Иди домой сопляк"
  
$${\color{orange}Какие \space операторы \space есть:}$$
* Арифметические операторы : -+/*
* Операторы присвоения: =
* Логические операторы: &&, ||,  !
* Составные операторы: +=, -=, /=, *=
* Операторы сравнения: ==, >, <, <=, >=, !=
* Операторы диапазона или ренж (…), (..<100), (10…), (...100)

---

## Хештруемые и сопоставимые данные
* Comparable тип данных которые можно сопоставить между собой с помощью операторов <,>,=<,=>. То есть сравнить их между собой и узнать больше или меньше… **bool** нельзя сопоставить. Он не может быть больше или меньше 
* Equatable позволяет сравнить через операторы ==, !=.
* Hashable если тип данных хешируемый то значение его типа имеет свойство hashValue к которому можно обратится! 

В Swift встроена хеш функция. Хеш-функция - это метод, который берет любой объект и вычисляет почти уникальное числовое представление объекта, которое может быть использовано в качестве ключа для последующего поиска. В хеш-таблицах очень быстро работает поиск - O(1). Но если вам придется пройтись по связанному списку, то в худшем случае это может быть O(n)

---

## Коллекции 

Есть три вида коллекций:
* Массив (Array)
* Словари (Dictionary)
* Сет (Set)
  
Различия между ними: 
У массива есть **индекс и значение**. Для поиска значения испльзуется индекс.
У словаря **есть ключ и значение**. 
У Set есть **ТОЛЬКО** значения. 

Так же в Set и в словаре **нет** постоянной последовательности, так как в них хранятся уникальные значения. В словаре не могут быть два одинаковых ключа так же как в Set не могут быть два одинаковых значения. 
У всех них есть различные методы, такие как:

* count
* isEmpty
* sorted
* reversed
* contains
* ect...

Коллекции могут быть изменяемые и неизменяемые**(let/var)**. Работают через дженерики<T>. 

**Value semantic** это референc типы которые ведут себя как тип значения!
**Array это value semantic**, он ведет себя как тип значения, но все его данные храниться в куче(heap)!!!

Set нельзя объявить упрошенным способом как массив или словарь, только через дженерик Set<Type>
В Set и в словари можно вставить только то что отвечает hashable протоколу. 

**Срезы массивов (ArraySlice)**
Дело в том, что ArraySlice не копирует исходный массив, а ссылается на его подмножество (если быть точным, то ссылается на ту же самую область памяти). Это 
сделано для экономии ресурсов компьютера, так как не создаются лишние копии 
одних и тех же данных. 

        // исходный массив
        let arrayOfNumbers = Array(1...10)
        let slice = arrayOfNumbers[4...6]
        slice // [5, 6, 7]
        // его тип данных отличается от типа исходного массива
        type(of: slice) // ArraySlice<Int>.Type

Стоит обратить внимание на то, что индексы ArraySlice соответствуют индексам 
исходной коллекции, то есть они не обязательно начинаются с 0

        // исходный массив
        arrayOfNumbers // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
        // его срез, полученный в одном из предыдущих листингов
        slice // [5, 6, 7]
        // отдельный элемент
        arrayOfNumbers[5] // 6
        slice[5] // 6


---

## Управление потоком

**К ним относятся циклы:**
* for in
* while
  
**Инструкции**
* if
* guard
* switch
  
Есть так же **repeat while** где условие выполняется на проверку в конце, то есть сначала будет выполнен код в repeat, а потом уже сравнивается условие. 

В **switch** есть **case**, где можно указать все нужные параметры через запятую a, b, c и так же у case есть временные переменные и дополнительная проверка с помощью слова **where**  

    switch anotherCharacter {
    case "a", "A":
        print("The letter A")
    default:
        print("Not the letter A")
    }

    switch yetAnotherPoint {
    case let (x, y) where x == y:
        print("(\(x), \(y)) is on the line x == y")
    case let (x, y) where x == -y:
        print("(\(x), \(y)) is on the line x == -y")
    case let (x, y):
        print("(\(x), \(y)) is just some arbitrary point")
    }
        
Еще есть операторы передачи управления:   
* continue
* break
* fallthrough
* return
* throw
  
**break** прерывает цикл сразу же и выходит из него.  
**fallthrough** перенаправляет на следующую итерацию, даже если первое условие верное. 
**continue** выходит из текущей итерации и передает цикл дальше к следующей итерации, не прерывая сам цикл или инструкцию.

**Маркер или ярлык** нужен для того, что бы дать имя внешнему циклу для прирывания его внутри внутреннего цикла\инструкции

    имя маркера: while условие {
         исполняемый код
    }

    gameLoop: while square != finalSquare {
        diceRoll += 1
        if diceRoll == 7 { diceRoll = 1 }
        switch square + diceRoll {
        case finalSquare:
            //после броска кубика мы попадаем на клетку 25, игра окончена
            break gameLoop
        case let newSquare where newSquare > finalSquare:
             //мы кинули кубик на слишком большое значение, значит нам нужно кинуть снова
            continue gameLoop
        default:
            //допустимое движение по игровому полю, двигаемся
            square += diceRoll
            square += board[square]
        }
    }
    print("Game over!")
    
---

## Регулярные выражения
Регулярные выражения позволяют нам выполнять сложные операции поиска и замены в тысячах текстовых файлов всего за несколько секунд. 
Regex - по сути он помогает проверить на валидность нужное тебе выражение, почту, строку и тд. Указываешь нужные параметры и готово. 

---

## Функции 
**Функция** - это отдельный блок кода, который выполняет определенную задачу. Она вызывается в нужном месте и в нужное время. 
У нее есть параметры для работы. Количество параметров не ограничено. У параметров есть внешние имена и внутренние.  
Так же в параметры можно передать значения по умолчанию через знак равно(=). 
**Вариативный параметры**
Еще есть вариативный параметры(три точки) которые можно указать после типа параметра, что бы он принимал при вызове функции сразу много значений, и тогда это сразу превратится массив… Можно использовать только один параметр в данной функции или несколько, но тогда нужно внешнее имя для второго вариативного параметра,то есть ярлык 

    func arithmeticMean(int: Int..., sumForDouble numbers: Double...) -> Double {}
    
**Сквозные параметры**
Параметры функции по умолчанию являются константами. Так как в функции нельзя изменять внешнюю переменную, ведь в функцию передается копия переданных данных, то для обхода данного фишки можно использовать ключевое слово **inout** перед типом. И тогда функция сможет изменять переменную, но не забудь добавить знак амперсанта **&** в передаваемых параметрах функции во время вызова.
Сквозные параметры не могут иметь значения по умолчанию, а вариативные параметры не могут быть сквозными, с ключевым словом inout.

**Higher-order functions (Функции высшего порядка):**
Это функции, которые вы передаете в качестве аргументов другим функциям. В этом простом примере, фильтр требует передачи функции высшего порядка.

---

## Замыкание
Ссылочный тип. Отдельный блок кода который можно вызвать в нужном месте.
Проще говоря, замыкание - это как небольшая анонимная функция, которая может быть передана другой функции, переменной или использована самостоятельно.
Completion handler с атрибутом @escaping - это специальный тип замыкания (closure) в Swift, который указывает на то, что это замыкание может "выбраться" (escape) из текущей области видимости и продолжить своё выполнение после завершения функции, в которой оно было передано. Нужно для асинхронного запроса. Вызовется в конце работы функции. Все опциональные замыкание по дефолту @escaping
То есть при сетевых запросах мы вызываем Completion handler для того, что бы выполнить какие то определение действия после завершения получения данных из сети.

Распространенным применением замыканий является обработчик завершения.
    •    Вы выполняете длительную по времени задачу в своем коде, например, загружаете файл, делаете расчет или ждете ответа веб-сервиса.
    •    Вы хотите выполнить некоторый код, когда долгая задача будет завершена, но вы не хотите постоянно выяснять статус, чтобы узнать, завершена ли она.
    •    Вместо этого вы предоставляете замыкание для долгой задачи, которое будет вызвано, когда задача будет завершена (отсюда название «обработчик завершения»).

## Перечисления
Enum это конечное множество. Помогает сократить количество ошибок при выборе или вводе какой то информации.
Перечисления используют тип значения, работают в стеке. У них есть кейсы(case) и есть функции. Так же есть сырое значение (rawValue) которе принимает имя Кайса за значение этого кейса при необходимости. Так же ест caseIteration который позволяет посчитать все кейсы и пройтись по ним в цикле. Еще есть ассоциативное значение у кексов. 

## Классы и структуры 
Классы это ссылочный тип. Структуры, Енамы и базовые типы это тип значения.
При создании класса используется куча, а у структуры используется стек. Указатели(ссылки) хранятся в стеке для ссылочного типа.
Все типы в Свифт работают как типы значения. Кроме функций, акторов и кложеров, они работают как ссылочный тип. Отличаются они тем что у структуры встроен по умолчанию инициализатор, структура не наследуется, и работает она через стек. классы и структуры имеют свойства и методы. 
Структуры и енамы не могут через свои методы изменять свои же свойства из-за того, что это тип значения, только если перед методом поставить слово mutating. Класс же может изменять в методе свои же свойства.
Сценарии когда тип значение лежит не в стеке - это когда внутри типа значение лежит ссылочный тип.

Если у вас есть класс с большим количеством методов, но вам нужно наследовать только небольшую часть из них, рекомендуется использовать композицию или агрегацию вместо наследования.
class MyFunctionality {
    func method1() {
        // ...
    }
    func method2() {
        // ...
    }
    // ... множество других методов ...
}

class Subclass {
    private let functionality = MyFunctionality()
    
    func method1() {
        functionality.method1()
    }
    
    // ... только нужные методы ...
}

---

## Свойства
Они бывают следующими: хранимые свойства, вычисляемые свойства, ленивые свойства, наблюдатели, а так же свойства типа(static). При чем свойства хранения отсутствуют в енамах. 
Свойства вычисления используют гетер и сетер, если установлен только гетер, то это вычисляемое свойство для чтения, без установки нового значения. 
Ленивые свойства вызываются только тогда, когда к ним обратятся, при инициализации они не вызываются. Lazy свойства могут быть только хранимыми, потому что они должны иметь значение до инициализации. То есть они не могут быть методом или вычисляемым свойством. 
Так же свойства наблюдатели не вызываются при инициализации, только когда к ним обратятся.
При создании класса, память не используется, так как при создании класса идет лишь описание его, но не инициализация. Память устройства испльзуется только при создании объекта. Различие между объектом и классом - объект занимает место в памяти, через объект можно обратиться к свойствам или методам класса, его можно менять. Класс же не занимает помять, не дает возможность с ним взаимодействовать и изменять его. Свойство типа позволяет обратится к свойству класса не создавая объекта в памяти устройства через слово static. 
Различие между static и class. class: Этот модификатор может быть применен только к свойствам и методам в классах. В отличие от static, свойство или метод с модификатором class может быть унаследован и переопределен в подклассах. Модификатор class не может быть у хранимого свойства, только у вычисляемого метода. class не применяется к хранимым свойствам, потому что они не имеют логики, которая может быть переопределена в подклассах. Структуры не могут быть синглтонами.

---

## Методы 
Методы так же могут как и свойства использовать слова static для определения метода без указания экземпляра. Так же в структуре и енаме методы не могут менять значение свойств без слова mutating. Методы так же имею параметры и возвращаемое значение как и обычные функции. Внутри метода неявно указывается self. 

---

## Опциональные значения
Опционалы нужны для предоставления возможности отсутствие значения где либо, например в переменной. Если рядом с типом поставить вопросительный знак, значит это уже будет другой тип, но с опциональным значением. Сравнивать Int и Int? Нельзя, так как это разные типы.
Бывают несколько опциональных значений:
    Первое это Force Unwrap которое извлекает опциональное значение принудительно через восклицательный знак «!». 
    Так же есть optional binding который позволяет извлекать безопасно опциональные значения. Для этого используется if let или guard let. При этом можно задать значение или вывести в консоль что либо при значении nil в переменной после извлечения, через else. 
    Так же существует optional chaining когда при например сложении обычной переменной и опциональной переменной ставиться вопросительный знак для опциональной переменной без безопасного извлечения. 
    Еще есть Implicitly Unwrapped Optionals когда в опциональном типе ставиться восклицательный знак вместо вопросительного, тем самым как бы утверждая, что данные тут точно есть и можно их извлекать до первого обращения к нему. 
    А еще есть nil-coalescing operator который предоставляет значение по умолчанию для опцианальной переменной используя два вопросительных знака ??. 
Устроен он как enum с двумя case в которых лежат два значения, то нее два рейса. В одном nil в другом value которе присватывается через ассоциативное значение используя <T> дженерики

---

## ООП
ООП это методология программирования, что проставляет программу на взаимодействие объектов, которые являются экземплярами определенных классов, а классы образуют иерархию наследования.
Принцыпы: ПИНа 
Полиморфизм - это когда один интерфейс но много реализаций. Когда класс делает, что то но с различными методами. Например класс Auto, он едет. Но реализация может быть разной, он может ехать быстро, медленно, удобно, или не очень. Та функция которая принимает  данный класс,  должна без проблем реализовать его работу, несмотря на различные методы. То если класс User принимает в свой метод drive класс Auto то все должно работать без проблем. 
Инкапсуляция - когда скрываешь реализацию от чужих глаз. То есть ты прячем саму реализацию от изменений. Иногда можно считать данные, но не менять реализацию. Пример - то как работает двигатель скрыт от водителя, он инкапсулирован. Но его можно использовать что бы авто двигалось вперед.
Наслелование - каждый наследуемый(подкласс) класс должен уметь делать все то, что умеет делать родительский класс.
Абстракция - это когда вместо класса авто, мы используем транспортное средство. Это нужно для расширения программы. Например у нас есть компания по доставке товаров. И по началу мы на доставку использовали только авто(класс  AUTO). Если компания вырастет, то надо будет доставлять товар и самолетом и поездом и тд. То есть класс АВТО уже не абстрактный, он привязан к определенным вещам и реализациям.
### Парадигмы программирования: 
* Императивное 
* Процедурное
* Структурное
* Функциональное 
* ООП - объекто ориентированное программирование
* ПОП - протоколо ориентированное программирование 
* Реактивное 

---
 
## Наследование
Наследование работает только с классами. Подклассы имею доступ ко всем свойствам и методам суперкласса. Подклассы могут наследовать от других подклассов. Тогда они будет иметь все свойства идущие по всей цепочке иерархии от суперкласса, до подкласса. Можно так же использовать супер класс как ТИП для экземпляров класса которые наследовали от суперкласса или подкласса в цикле, массиве и тд.
Подклассы могут переопределять свойства и методы супер класса с помощью слова override. Что бы запретить переопределение, нужно использовать слово final перед свойствами или методами, а так же можно запретить наследованная от супер класса написав final class. 
Можно переопределить хранимые свойства добавлением гет сет, так же и у вычисляемых свойств. Нельзя переопределись константы let и только читаемые вычисляемые свойства. Должно быть гет сет. 
### Минусы - наследование.
Почему? Потому что глубокая иерархия наследованная, и если будет баг в середине этой цепочки, то непонятно куда идти, вверх или вниз по цепочке.
Нет множественного наследованная. По этой причине при изменении в методе чего либо влияет на его потомком. Можно решить множественное наследованные с помощью протоколов, тот же Codable. 

---

## Инициализация
Инициализация это когда устанавливаются свойства, а не объект. Задачи инита установить все хранимые свойства для гарантии работы объекта. Это подготовительный процесс экземпляра класса и установка начальных значений свойств. 
В инициализации нельзя вызвать метод, пока не будут указаны все свойства что есть в классе.
Если установленные значения по умолчанию для свойств, то в инит при сознании экземпляра не обязательно устанавливать значения для свойств. Даже сам инит не надо писать. Если по умолчанию опциональное свойство, то его значение равно nil.

    class ShoppingListItem {
        var name: String?
        var quantity = 1
        var purchased = false
    }
    var item = ShoppingListItem()

В структуре что бы не пропал инициализатор по умолчанию создав свой инит внутри структуры, надо создать инит в extention, тогда при создании экземпляра инит останется в структуре.
Только в Классе есть два инита : основной это Дизигнейтед(Назначенные) и Конвиниент(Вспомогательные)(пишется впереди слова init) нужен для того, что бы из дополнительного инита отправлять данные в другой инит.
Методы не могут быть вызваны в ините перед свойствами, только после инициализации всех свойств, и супер.инит тоже.  

    init(language: String = "Swift") {
            self.language = language
            super.init(name: "UNKNOWN", salary: 100)
            addSalary()
        }
        
Правило номер 1. Нельзя вызвать в дезигнейтед инит супер.конвиниет инит, только дезигнейтед…
Правило номер 2. Если вызываешь один инит в другом , то должен использовать слово конвиниент.инит
Правило номер 3. Если вызываешь конвиниет инит, то последним должен быть обязательно только дезигрейтед инит, даже если конвиниет будет вызывать еще несколько конвиниентов.

Как произсходит инициализация. Если в наследнике вызвать супер.инит то он сначала проинициализирует свои свойства, далее пойдет к супер классу, произведет там инициализацию свойств, изменит если что то там было во второй фазе, и уже после этого вернется к наследнику для изменений свойств в ините, вторая фаза будет. Первая фаза инициализация всех свойств, вторая фаза это изменения свойств.

Есть так же fallible init?(Проваливающийся инициализатор) Который отмечается знаком вопроса после слова инит и он возвращает nil если какие то условия указаны в самом ините. Через ту же проверку guard else или if 

Так же есть required init(требуемые инициализоторы) который указывается в суперкласс, что бы он был обязательно вызвал в подклассе. Причем если его не вызвать, то будет ошибка. Так же в подклассе в required init надо будет удалить строчку fatalError что бы программа не сломалась в runTime. Нужно туда вписать корректные и нужные параметры.

Начальное значение свойства в виде замыкания. после закрывающей фигурной скобки замыкания идут пустая пара круглых скобок. Это означает, что нужно исполнить это замыкание немедленно. 

    class SomeClass {
        let someProperty: SomeType = {
          // создаем начальное значения для SomeProperty внутри этого замыкания
          // someValue должен быть того же типа, что и SomeType
          return someValue
        }()
    } 
    
---

## Деинициализация
Деинилизация нужна для того, что бы освободить зарезервированную память от экземпляра класса. То есть идет подготовка к высвобождению памяти.
Она может быть только у класса, только.
После выхода из области видимости, то есть из скобок do {} или func {} объект умирает. 
Так же что бы не исползать область видимости, можно привести экземпляр к опциональному типу и установить nil.

    class Boomb {
        var damage: Double = 50
        
    deinit {
        print(«Освободил память Booooom»)      }
    }
    var boomb: Boomb? = Boomb (V
    boomb = nil
    
При наследовании, освобождается сначала подкласс, а после уже супер класс(всплытие так сказать от подкласса до супер класса)
Определения класса могут иметь максимум один деинициализатор на один класс. Деинициализатор не принимает ни одного параметра и пишется без круглых скобок.

---
## Обработка ошибок
Это нужно, что бы понимать какая ошибка произошла, и соответствующим образом изменить код!
Для того чтобы «сгенерировать» ошибку, вы используете инструкцию throw. 
Используется для обработки ошибок при работе с сетью… 
В функции пишется throws и дальше помечаются ошибки словом throw. 
Обрабатывать ошибки могут функции, методы и инициализаторы

Обработка ошибки должно происходить в блоке do catch и словом try
Try всегда пишется в блоке do-catch иначе будет ошибка
Если функция реализует ошибку do-catch то она должны в catch использовать все возможные варианты ошибок, и для этого нужно дополнительно указать catch без указания енама с ошибками. Либо не писать последний catch и и указать в конце функции слово thows
Defer
Вы используете оператор defer для выполнения набора инструкций перед тем как исполнение кода оставит текущий блок. Это позволяет сделать любую необходимую очистку. Он выполниться после return и перед выходом из области видимости… пишется обычно в начале области видимости. Если указаны несколько defer то они выполняться в обратном порядке, снизу вверх: вот пример 

    func deferTest() -> Strina {
        var currentString = «»
        currentString += "A"
    
    defer {
            currentString += "B"
    }

    if true {
    defer {
        currentString += "C"
    }
    defer {
        currentString += "D"
    }
    currentString += "E"
    }

    currentString += "F"
    defer {
        currentString += "G" 
    }

    return currentString
    }
    Это будет равно =  A E D C F // эти буквы будут присвоены уже после return. Но при вызове функции мы их не увидимG B

---
## Расширения 
Это дополнительный функционал для класса стурктуру и тд, для типа. В расширениях по умолчанию нельзя использовать свойства хранения(сторед прочерти). 
По сути расширения нужны для разбивки кода для удобства пользования. Когда в отдельный файл нужно засунуть расширения какого то типа, то нужно указать так: ViewController + Extension. То есть есть внеклассное указание что для таких файлов надо указывать знак Плюс.
Если для стуктуры объявить инит в расширении то дефолтный инит не пропадет в структуре и будет два ини . Если же написать инит в структуре то дефолный инит пропадет.
Метод объявленный в наследнике не может быть переписанным(override). Extension + override не работают по умолчанию.
 Есть обходной путь, можно в классе перед методом написать @objc dynamic func test() {} и уже после override func будет работать в расширении.
Вопрос почему нельзя использовать хранимые свойства в расширении. Ответ - Расширение не имеет собственного хранилища для хранения состояния свойств.

---
## Протоколы
Протокол определяет образец методов и описывает как реализация должна выглядеть. Протокол может быть принят классом, структурой или перечислением.
Протокол это набор методов и свойств без реализации. То есть из него нельзя сделать объект как из класса. Протокол это тип как класс структура или Енам. 
Класс подписанный на протокол обязан реализовать все свойства и метода из протокола.
Что бы использовать протокол только для класса, нужно после типа протокола указать AnyObject(Раньше это слово было class)
Если использовать расширение протокола Extension SomeProtocole, то в нем можно реализовать все свойства и метода протокола для использования их по умолчанию. И когда класс будет подписан под этот SomeProtocole то ему не надо будте реализовывать все эти свойства протокола. 
Так же существует так называемая ошибка Diamond problem которая при множественной реализации через расширения(установка по умолчанию) одного и тоже же метода или свойства, Свифт не понимает что ему выдать, и выдает ошибку. НАпример есть основной протокол ,и от него идет еще два что подписанный на него, и вот эти два протокола через расширения устанавливают значения по умолчанию, и если подписать класс на оба этих протокола, то Свифт не поймет какой брать, и будет ошибка.
Что бы ее избежать надо в классе(или расширении) переписать этот метом или свойство. 
Тоже самое может быть если сделать два одинаковых метода в двух наследниках протокола. Управляем точно так же, прописывает снова руками в классе.
Вам не нужно писать слово mutating при реализации этого метода для класса. Слово mutating используется только структурами или перечислениями.
Синтаксис наследования протокола аналогичен синтаксису наследования класса, но с возможностью наследовать сразу несколько протоколов, которые разделяются между собой запятыми
композиции протоколов это тип, который будет соответствовать сразу нескольким протоколам. можете перечислить столько протоколов, сколько нужно, разделяя их между собой знаком амперсанда (&).  func wishHappyBirthday(to celebrator: Named & Aged)
Опциональные требования для протокола. протоколы с маркировкой @objc могут приниматься только классами, но не структурами или перечислениями. Опциональное требование протокола может быть вызвано при помощи опциональной цепочки. должны иметь префиксный модификатор optional и @objc

    @objc protocol CounterDataSource {
        @objc optional func increment(forCount count: Int) -> Int
        @objc optional var fixedIncrement: Int { get }
    }

---
## Дженерики
Универсальный код позволяет вам писать гибкие, общего назначения функции и типы, которые могут работать с любыми другими типами
Универсальный тип, используется в коллекциях(массив, словари, сет) а так же в опциональных типах.
Использование в функциях, структурах или классах, протоколах
Протокол дженерик - В протоколах нельзя писать <T>. Его можно сделать дженерик только с использованием ключевого слова associatedType T. При подписании класса или структуры на дженерик протокол, внутри указывается typealiace T = Int. Если же класс или структура уже дженерик, то это уже можно не писать.
По сути дженерик нужен только для того что бы переиспользовать код(DRY)
### Минусы - дженерики увеличивают время компиляции и размер приложения, сложный дебагинг 

---
## ARC
**ARC**  - для отслеживания и управления памятью вашего приложения
**weak и unowned** - weak опциональный. Еще unowned быстрее, производительность.
weak let  pidr: Contact? 'weak' must be a mutable variable, because it may change at runtime - то есть он должен быть переменной, что бы вернуть nil потому как он опциональный… никаких let вместе с weak
Он работает только с референс типами(ссылочный типы). Классы, кложеры и акторы.
ARC автоматический считает Стронг ссылки делая +1 каждый раз при Стронг ссылки. Weak unowned не считают ссылки, то есть нет +1. 
Объект считается мертвым когда количество ссылок на него будет равно 0
Глобальные переменные хранятся в GVAR, то есть в памяти глобальных переменных, не в СТЕК и не в КУЧЕ.
Есть менеджеры памяти - это strong weak unowned ссылки. 
По умолчанию создается Стронг ссылка. Пока есть Стронг ссылка, этот объект будет существовать в куче.
Weak и Unowned ссылки не удерживают объект в памяти.Они нужны, что бы разорвать рефери цикл(утечку памяти). Разница в том, что при освобождение из памяти Weak становиться nil. А unowned продолжает хранить ссылку (будет крэш приложения)
Утечка памяти происходит потому что объекты ссылаются друг на друга, тем самым создавая еще больше Стронг ссылки. Тем самым уже не по одной Стронг ссылке есть, а по две и deinit и даже nil не поможет. Будет утечка памяти до тех пор пока вся память не кончиться и приложение закроется. Что бы остановить это, нужно указать внутри класса weak перед свойством что держит другой класс. Weak var person: Person? = Person. 
Если в кложуре много будет self, и произойдет то, что мы вышли из этого места выполнения кода, а он продолжился… 
для этого надо использовать стронг ссылку 

    guard self = self else { return }
    
В отличии от слабых ссылок, бесхозные(unowned) ссылки всегда имеют значение. Из-за этого бесхозные ссылки имеют неопциональный тип. 

---
## Тип памяти
Две области в оперативной памяти - Стек и Куча
Стек работает по принципу LIFO последний пришел первый вышел
Указатели или ссылки класса лежат в стеке, а сам класс лежит в куче
Бывают три типы памяти
Статическая 
Динамическая для кучи. Используется для динамического выделения памяти
Автоматическая для использования стека 
Стек создается во время компиляции, куча инициализируются  во время запуска приложения 

---
## Делегирование
Делегирование – это шаблон проектирования, который позволяет классу передавать или «делегировать» некоторые из своих обязанностей другому классу.
Представьте, что вы и я – часть команды, которая доставляет шоколадное печенье на мероприятие. Ваши обязанности заключаются в выпечке печенья, и вы делегируете на меня изготовление теста для печенье. Когда я закончу, я отдам вам тесто для печенья, чтобы вы могли его испечь.
Делегирование – один из самых распространенных шаблонов проектирования в iOS. Практически невозможно создать приложение для iOS без использования делегирования.
Для этого нужно: 
Протокол Класса. 
Свойство в первом объекте вид делегат. 
Второй объект должен подписаться и стать делегатом.

--
## Тайпкастинг 
Any нужен для использования когда не знаешь кокой конкретно тип будет в массиве. В any можно засунуть все что относиться к типу значения. 
К AnyObject можно засунуть только ссылочный тип, такие как классы и кложеры. Класс можно и в Any засунуть но…
is это проверка типа, работает в пару с Any. as это уже приведение типов одного к другому. Upcasting. Так же есть Downcasting который использует as?! Опцианальный as работает во время компиляции, в то время как as? работает в runtime, то есть когда работает приложение. От этого может страдать производительность. От as?.
Понижающее приведение
Опциональная форма (as?)
принудительная форма (as!)

---
## Контроль доступа
Это структурирование и защита кода от внешних воздействий
Есть несколько доступов:
Open
Public
Internal 
Fileprivate
Private 
Open и public нужны для доступа к классам. Fileprivate и private закрывают доступ. Fileprivate доступен только в файле. Private не доступен.
По умолчанию все находится в internal. Если в классе написать доступ private то и все свойства и методы тоже будут приватными. Что бы получить доступ к приватному классу, надо так же указать private для экземпляра класса. 
Для тестов нужно прописывать @testable
Подкласс не может быть уровнем доступа выше чем его супер класс: вы не можете написать подклассу public, если его суперкласс имеет internal доступ.

---
## Singleton 
При объявлении класса синглтоном ты не можешь создать много экземпляров этого класса, так как он один работает теперь на всем проекте.
Singleton - это паттерн проектирования в программировании, который позволяет создать класс таким образом, чтобы у него был только один единственный экземпляр во всем приложении. Это полезно, когда у вас есть компонент, который должен существовать в единственном экземпляре, чтобы обеспечить глобальный доступ к его функциональности.
Нарушает принцип единственной ответственности класса.

---
## Менеджеры зависимостей
Это менеджер по управления и подключению разных библиотек к твоему проекту. SPM проще. CocoaPods сложнее и при это после установки нужно использовать белый файл проекта, а не синий. Все зависимости нужно писать в отдельный файл и делать pod init pod instal.

---
## Жизненный цикл приложения
приложение посылает сообщения классу appDelegate, в котором можно эти сообщения поймать и обработать, так же 
происходит посыл сообщения NSNotificationCenter с соответствующим содержанием для каждого из состояний приложения.
Сначала приложение не запущенно. Потом пользователь запускает приложение. Оно переходит в состояние в состояние Foreground, в котором приложение становится сначала Iactive —  на этом этапе выполняется код программы, но не обрабатываются события интерфейса пользователя (интерфейс не отображается, касания не обрабатываются и.т.п.). Затем переходит в этап Active, в котором выполняется код и обрабатываются все события UI. 
Если пользователь запустит другое приложение, то текущее приложение перейдет в состояние Inactive и затем в состояние Background. В этом состоянии коды выполняется ограниченное время, и не обрабатываются события UI. Нужно понимать, что именно в этом состоянии можно заставить приложения получить, допустим, из интернета самые свежие обновления чего либо, и дать их приложению, что бы когда пользователь вернул приложение в Foreground он мог увидеть эту информацию. Так же нужно понимать, что при включенном режиме энергосбережения могут эти процессы в background и не выполнится…
После весьма короткого состояния Background  приложение переходит в состояние Suspended. В этом состоянии код не выполняется вовсе и система может убить приложение для освобождения памяти, если оно потребуется.
Список делегатов
sceneWill Resigh Active - собирается стать неактивным
sceneDid Enter Background - стало нёактивным
sceneWill Enter Foreground - собирается вернуться на передний план
sceneDid Become Active - стало активным
sceneDidDisconnect
Вопросы на собесе:

Какие этапы проходит приложение, перед тем как появиться на экране, после перегрузки устройства?
    * Перезагрузка устройства = Переводит приложение в состояние «не запущено», даже если оно продолжает находиться в диспетчере приложений.
    * Когда пользователь запускает приложение в первый раз или после перезагрузки система переходит через следующие стадии:
    * не запущено -> не активно -> активно

Как приложение реагирует на прерывания, такие как СМС сообщения, входящий звонок, календарь и т.д. ?
* Приложение временно переходит в неактивное состояние и остается в нем до тех пор, пока пользователь не решит, принять или проигнорировать прерывание;
App in foreground
* Если пользователь игнорирует прерывание, приложение снова активируется;
Incoming call or sms or calendar notification
* Если пользователь принимает прерывание, приложение переходит в состояние приостановки.

Существует множество причин, по которым приложение может быть запущено: нажатие на иконку на домашнем экране, поступление push-уведомления, перехват ссылки, меню быстрых действий и др. В одних случаях будет загружен и отображен графический интерфейс, а в других вся работа будет выполняться в фоновом режиме. 

---

## Жизненный цикл ViewController

    * init
    * loadView
    * viewDidLoad
    * viewWillAppear
    * viewWillLayoutSubviews 
    * viewDidLayoutSubviews
    * viewDidAppear
    * viewWillDisappear
    * viewDidDisappear
    * deinit
    
 Еще есть didReciveMemoryWarning для того что бы можно было отследить утечку памяти или вся память заполнена.
 И viewWillTransitionToSize если нужно самостоятельно обработать анимацию при повороте, то можно его. 

    * init - установка свойств vc;
    * loadView - подмена стандартной view на кастомную;
    * viewDidLoad - view нашего ис создано, используется для заполнения UI;
    * viewWillAppear - vc начинает начинает появлять на экране, используется для обновления UI данными, которые могли измениться, пока ус не отображался на экране;
    * viewWilLayoutSubviews - вызывается перед тем как view нашего vc, разместит свои subviews. Границы окончательно подсчитаны.
    * view DidLayoutSubviews - уведомляет, что view нашего ус только что разместила свои subviews;
    * viewDidAppear - вызывается как только ис появился на экране;
    * viewWillDisappear - vc начинает удаляться с экрана;
    * viewDidDisappear - vc удален с экрана;
    * deinit - деинициализация vc, удаление из памяти устройства;
    
SwiftMagic

Итак, основная разница заключается в том, что loadView отвечает за создание и инициализацию представления контроллера, в то время как viewDidLoad предназначен для настройки и инициализации данных уже существующего представления.

---

## Императивный Декларативный
Императивный подход основывается на определении последовательности команд и операций, которые выполняются шаг за шагом в определённом порядке. Разработчику необходимо подробно описать, как программа должна работать и какие операции должны быть выполнены, чтобы добиться нужных результатов.
Декларативный подход, в свою очередь, сфокусирован на том, чтобы описывать, что программа должна делать, а не как это должно быть выполнено. Разработчик описывает желаемый результат, а система сама определяет, как его получить.

--- 
## GCD задачи

Если в задаче стоит DispatchQueue.main.async то он будет выполняться после того как выполниться функция. То есть  async отложит выполнение на потом. 

    func firstMethod() {
        print ("A" )
    
        DispatchQueue.main. async {
            print ("B" )
            }
    
        print("C" )
    }
    firstMethod () // A C B

Если там будет стоять sync просто, то будте runtime ошибка, потому как синк будут запушен для выполнения не дождавшись окончания функции из главного потока. И функция так же незавершится, так как ждет пока sync закончит выполнение задачи. Короче мешают друг другу. При такой записи не будет ошибки: Dispatchadieue.global().sync, он выполнит код в бекграунде, не в основном потоке main.

___

## User Defaults
User Defaults обеспечивает долговременное хранение дат, числовых, логических, строковых и других типов данных. Удаление приложения из устройства приводит к уничтожению всех данных в User Defaults. 
Основное предназначение User Defaults – хранение различных параметров пользователя (имя, почтовый адрес, возраст, пол), настроек приложения (вы- бранный язык, валюта, цветовая схема) и различные флаги, содержащие логи- ческие значения («была ли показана инструкция при входе», «были ли синхро- низированы данные с сервером»). 
User Defaults хранит данные в plist-файлах. 
работает на основе паттерна «Одиночка» (Singleton). 

---

## Size Class
Нужно для того что бы использовать приложение в разных положениях. В горизонтальном и в вертикальном. (Compact and regular)
В большинстве случаев, для адаптации к изменению ориентации экрана более подходит viewWillTransition(to:with:), так как он предоставляет конкретную информацию о новом размере экрана и длительности анимации перехода.
Какой использовать и когда:
    * Используйте viewWillTransition(to:with:), когда вам нужно выполнить действия, специфичные для изменения ориентации экрана. Например, вы можете перестроить интерфейс, пересчитать размеры элементов или изменить расположение ваших представлений.
    * Используйте traitCollectionDidChange(_:), когда вам нужно реагировать на изменение trait collection в более общем контексте, который может включать в себя не только изменение ориентации, но и другие факторы, влияющие на пользовательский интерфейс.


    override func traitCollectionDidChange(_ previousTraitCollection: UITraitCollection?) {
        if view.traitCollection.horizontalSizeClass == .compact {
        
        }
        
        if view.traitCollection.verticalSizeClass == .regular {
        
        }
    }

---

## Frame Bounds
Размеры графического элемента в родительской системе координат называются frame, а в собственной системе координат – bounds. 
Вот ответ на заданный выше вопрос: 
«Свойство frame определяет, где находится представление в системе координат супервью. Свойство bounds определяет внутренние размеры и положение представления относительно собственной системы координат». 
    * frame - это прямоугольник, который определяет положение и размер вьюхи в системе координат супервью. Он задается четырьмя значениями: x, y, width и height.
    * bounds - это прямоугольник, определяющий размер и координаты внутри вьюхи в её собственной системе координат. По умолчанию начало координат этой системы находится в верхнем левом углу вьюхи.

---

### UIResponder 
Для обработки событий, возникающих в процессе жизненного цикла приложения, служат разнообразные механизмы. Так, например, для работы с касаниями используется класс UIResponder, для обработки push-уведомлений – Notification Center, для запуска таймера – класс Timer и т.д. 
класс UIResponder содержит в себе функциональность для реагирования не только на события касания, но и на нажатия физических клавиш, движения устройства (например, встряхивание) и команды от внешних аксессуаров (напри- мер, гарнитуры). Это становится возможным благодаря переопределению в до- чернем классе (который должен обрабатывать события) специальных методов. К примеру, для обработки касаний используются следующие четыре метода: 
touchesBegan(_:with:) – палец коснулся экрана; ● touchesMoved(_:with:) – палец движется по экрану; ● touchesEnded(_:with:) – палец прекратил касание; ● touchesCancelled(_:with:) – касание отменено. 
Для обработки нажатий физических клавиш используются методы pressesBegan, pressesChanged, pressesEnded, pressesCancelled, для движений – motionBegan, motionEnded и motionCancelled, а для внешних устройств – метод remoteControl Received.

---
 
## Responder Chain – это список вероятных ответчиков, т.е. список объектов, которые потенциально могут обработать возникшее событие. Если очеред- ной элемент списка (цепочки) не может обработать событие, оно передается следующему в списке элементу. Responder Chain – это реализация шаблона разработки «Цепочка обязанностей». Его суть состоит в том, что элементы поочередно опрашиваются на предмет возможности обработки поступивших данных. Если один элемент не смог обработать его, данные о событии передаются следующему элементу в цепочке и т.д. Тот элемент, по которому происходит касание, назначается первым ответчиком (first responder). Если он может обработать событие, он делает это, если нет – передает управление следующему элементу цепочки, и цикл вновь повторяется до тех пор, пока не будет найден элемент, способный обработать событие. Все элементы цепочки ответчиков являются наследниками класса UIResponder. 
Но изначально на сцене нет никакого первого ответчика. В случае события «Касание» он определяется следующим образом: 
* UIKit создает объект типа UIEvent, подробно описывающий событие; 
* данный объект отправляется в UIApplication и, далее, в UIWindow; 
* UIWindow проводит так называемое hit-тестирование, т.е. с помощью поэтапного вызова метода hitTest(_:with:) для каждого вложенного представления, определяет, с каким именно графическим элементом взаимодействует пользователь; 
* как только данный элемент найден, он назначается первым ответчиком, и начиная от него стартует обход Responder Chain. 
Для всех остальных типов событий (нажатия физических кнопок, движения гарнитуры и команд от внешних устройств) никакого hit-тестирования не про- водится. Данные передаются сразу в элемент, который в текущий момент является первым ответчиком (если он был определен ранее). 
Вы можете влиять на то, какой элемент должен быть первым ответчиком в данный момент с помощью вызова метода becomeFirstResponder() 

___

## UIView
по умолчанию для экземпляра UIView отклю- чена поддержка мультитач (одновременное касание несколькими пальцами). 
Для включения поддержки мультитач конкретному вью необходи- мо установить значение true в свойстве isMultipleTouchEnabled. 

---

## Auto Layout
Auto Layout — это технология, основанная на понятиях ограничения (constraint) интерфейса. Она динамически вычисляет размер и положение всех графических объектов в иерархии UIView, основываясь на ограничениях, указанных для этих объектов. Если размеры экрана отличаются, то Auto Layout автоматически расположит графический объект на нужное место. Такой подход к проектированию позволяет создавать гибкий (flexible) интерфейс, который может динамически реагировать на внутренние и внешние изменения (например, изменяется ориентация экрана, изменяется размер одного из объектов и т.д.).

---

## Auto Layout и Constraint Resistance
Для некоторых UIView мы не всегда можем применить конкретные значения. Например, если у нас есть UIButton с Tapжестко заданным значением, при локализации текст может быть обрезан.
Чтобы справиться с этим, не требуя изменения приоритета, мы можем использовать другой набор функций, чтобы избежать такого поведения. Двумя из них являются Content Hugging и Content Resistance.
    * Content hugging priority - приоритет сопротивления превышения intrinsic content size (не хочу чтобы была больше)
    * Content compression resistance priority - приоритет сопротивления занижения intrinsic content size (не хочу чтобы была меньше)

---
 
## Антипаттерн
* Лодочный якорь (Boat anchor) паттерн YAGNI
Этот анти-паттерн означает сохранение неиспользуемых частей системы, которые остались после оптимизации или рефакторинга. Часто, после рефакторинга когда, который является результатом анти-паттерна, некоторые части кода остаются в системе, хотя они уже больше не используются. Так же некоторые части кода могут быть оставлены «на будущее», авось придётся ещё их использовать.

* Спагетти-код (Spaghetti code) паттерн Единой ответсвенности. 
Спагетти-код — слабо структурированная и плохо спроектированная система, запутанная и очень сложная для понимания.
Причинами являются — разработка по принципу «Да ну, оно же работает! Целых пять тысяч строк!», малоэффективные code review, 

* Solid Одиночка — это порождающий паттерн проектирования, который гарантирует, что у класса есть только один экземпляр, и предоставляет к нему глобальную точку доступа.
Нарушает принцип единственной ответственности класса.

---

## Side tables 
Вкратце, Side Table — механизм, с помощью которого реализуются слабые ссылки. Не каждый объект содержит слабые ссылки, следовательно, и боковые таблицы, иначе это было бы расточительно. Вместо того чтобы напрямую указывать на объект, слабая ссылка указывает на боковую таблицу, которая, в свою очередь указывает на объект. Такое поведение решает две проблемы: Экономия памяти, поскольку память объекта освобождается. Наличие безопасного обнуления слабой ссылки. 

### Side tables — это механизм для реализации слабых ссылок Swift.
Обычно объекты не имеют слабых ссылок, поэтому резервировать место для подсчета слабых ссылок в каждом объекте нецелесообразно. Эта информация хранится извне в дополнительных таблицах, поэтому ее можно выделить только тогда, когда это действительно необходимо.
Как только мы начинаем ссылаться на объект слабо (weak reference), то создается боковая таблица, и теперь объект вместо сильного счетчика ссылок хранит ссылку на боковую таблицу. Сама боковая таблица также имеет ссылку на объект.
### Side Table — это просто счетчик ссылок + указатель на объект.

Механизм "side tables" в Swift используется для отслеживания слабых ссылок и управления памятью для них. Он связан с реализацией подсчета ссылок (reference counting) в Swift.
Когда вы создаете слабую ссылку на объект, Swift использует "side table" для хранения дополнительной информации о ссылке, такой как информация о циклических зависимостях. Это позволяет Swift отслеживать, когда объект, на который вы создали слабую ссылку, был деинициализирован, и автоматически обнулять эту ссылку.

---

## Hashable
Протокол Hashable используется для определения уникальности объекта в коллекции. Для того, чтобы тип был совместим с Hashable, он должен реализовать свойство hashValue и функцию операции равенства (==).
Хеш-функция (англ. hash function от hash — «превращать в фарш», «мешанина»), или функция свёртки — функция, осуществляющая преобразование массива входных данных произвольной длины в выходную битовую строку установленной длины, выполняемое определённым алгоритмом. Преобразование, производимое хеш-функцией, называется хешированием.
Простыми словами: Хеш-функция - это метод, который берет любой объект и вычисляет почти уникальное числовое представление объекта, которое может быть использовано в качестве ключа для последующего поиска.
Хеш-таблица — это структура данных, реализующая интерфейс ассоциативного массива, а именно, она позволяет хранить пары (ключ, значение) и выполнять три операции: операцию добавления новой пары, операцию поиска и операцию удаления пары по ключу.

---

## GCD
GCD поддерживается как в iOS, так и в macOS, watchOS и tvOS
Очередь работает по принципу FIFO, таким образом первая задача на очереди будет первой направлена на выполнение на потоке.
Мультипоточность в программировании позволяет выполнять несколько задач (или потоков) одновременно, что может значительно повысить производительность приложений. В Swift и других языках программирования существует несколько способов реализации мультипоточности, и одним из самых распространенных инструментов для управления потоками в Swift является GCD.
### GCD (Grand Central Dispatch) - это технология в Swift и Objective-C, предназначенная для управления параллельными задачами. Она обеспечивает простой способ создания и управления потоками. Основная идея GCD заключается в том, что вы можете определить задачи (или блоки кода) и отправить их в определенные очереди выполнения. GCD автоматически управляет выполнением этих задач на доступных ядрах процессора, что делает мультипоточное программирование более удобным и эффективным.
В GCD существуют два основных типа очередей:
    * Очереди серий (Serial Queues): Задачи в таких очередях выполняются последовательно, одна за другой, и в одном потоке, в порядке их добавления в очередь. Это полезно, когда важна последовательность выполнения задач.
    * Очереди конкурентности (Concurrent Queues): Задачи в таких очередях выполняются параллельно, в нескольких потоках, но порядок их выполнения не определен. Это позволяет использовать все доступные ядра процессора для более быстрого выполнения задач. Процесс переключения между потоками является одним из самых ресурсозатратных в многопоточной среде, а имя ему context switch.


В GCD (Grand Central Dispatch), main, global и custom представляют собой разные очереди выполнения (dispatch queues), которые используются для управления параллельными задачами. Давайте разберемся с каждым типом:
    * Главная очередь (main): Это специальная очередь, предназначенная для выполнения задач на главном потоке вашего приложения. Все пользовательский интерфейс (UI) обновления и взаимодействия с элементами пользовательского интерфейса должны выполняться на главной очереди. Попытка выполнить задачи, изменяющие интерфейс, на других очередях может привести к проблемам и нестабильной работе приложения. Это serial очередь.
    * Глобальные очереди (global): Глобальные очереди предоставляют доступ к готовым к использованию потокам в GCD. Они делятся на несколько уровней приоритета, обозначенных как "quality of service" (QoS). Например, есть очереди с приоритетами .userInteractive, .userInitiated, .default, .utility и .background. Вы можете выбрать подходящий уровень приоритета в зависимости от того, насколько быстро вы хотите, чтобы задача была выполнена и как она влияет на производительность системы. Это conrurrent очереди.
    * Пользовательские (custom) очереди: Пользовательские очереди - это очереди, которые вы можете создать самостоятельно для выполнения задач с определенными требованиями или приоритетами. Вы можете создавать пользовательские очереди с различными приоритетами и настраивать их в соответствии с вашими потребностями. 


Эти значки, такие как .userInteractive, .userInitiated, .default, unspecified, .utility и .background, представляют разные уровни "качества обслуживания" (Quality of Service, QoS) в Grand Central Dispatch (GCD). Они используются для управления приоритетами выполнения задач в глобальных очередях в зависимости от их важности и воздействия на производительность.
    *.userInteractive: Этот уровень QoS предназначен для задач, которые взаимодействуют с пользователем и требуют максимальной отзывчивости. Это могут быть анимации пользовательского интерфейса, реакция на жесты и другие действия пользователя. Задачи с этим уровнем приоритета выполняются немедленно и максимально быстро.
    * .userInitiated: Этот уровень подходит для задач, инициированных пользователем, которые необходимо выполнить с высоким приоритетом. Это могут быть загрузки данных по запросу пользователя или другие операции, которые пользователь ждет. Задачи с этим уровнем приоритета выполняются быстро, но не столь критичны для отзывчивости, как .userInteractive.
    * .default: Этот уровень QoS является стандартным уровнем и используется для большинства общих задач. Это может включать в себя обработку данных, вычисления и другие операции, которые не имеют высокой степени влияния на производительность или отзывчивость приложения. Задачи с этим уровнем приоритета выполняются в среднем темпе.
    * .utility: Этот уровень предназначен для задач, которые могут выполняться длительное время и не требуют максимальной отзывчивости. Это могут быть фоновые операции, такие как индексация данных или регулярные обновления. Задачи с этим уровнем приоритета выполняются медленнее, чтобы не конкурировать с более важными задачами.
    * .background: Этот уровень предназначен для фоновых задач, которые выполняются без непосредственного воздействия пользователя и не критичны с точки зрения производительности. Это могут быть - отправка данных для аналитики, синхронизация данных с сервером, загрузка контента в фоновом режиме и другие асинхронные операции. Задачи с этим уровнем приоритета выполняются очень медленно и имеют самый низкий приоритет.
    * .unspecified GCD определяет приоритет задачи на основе контекста, в котором она выполняется, или на основе настроек по умолчанию для данного типа задачи.

---

### DispatchWorkItem
Это класс, являющийся абстракцией над выполняемой задачей, который предоставляет нам ряд полезных методов. Например метод notify, позволяющий уведомить какую-либо очередь о выполнении задачи и следом выполнить какую-либо работу на уведомленной очереди. DispatchWorkItem позволяет нам более явно задать логику, без использования вложенных друг в друга замыканий и хаотичных вызовов методов async / sync. Помимо notify, DispatchWorkItem дает нам возможность отменять задачу с помощью метода cancel. Важно понимать, что задачу можно отменить только в том случае, если она на момент отмены ожидает в очереди. Если поток уже начал выполнять задачу, она не будет отменена. Метод notify вызовется даже при отмененной задаче.

### Semaphore
Это базовый инструмент синхронизации в GCD. Semaphore позволяет нам ограничить количество потоков, которые могут единовременно обращаться к очереди. Для этого необходимо передать количество потоков в инициализатор класса DispatchSemaphore. Помимо ограничения количества потоков, семафор позволяет блокировать очередь до тех пор, пока не будет вызван метод signal. 
Есть инкримент и дикримент wait() signal()

### DispatchGroup
Это объект, позволяющий объединить задачи в группу и синхронизировать их поведение. Группа позволяет присоединить к ней несколько задачь или DispatchWorkItem и запланировать их асинхронное выполнение на одной или нескольких очередях. Когда все задачи в группе будут выполнены, группа уведомит об этом какую-либо очередь и выполнит на ней completion handler. Так же группа позволяет нам дождаться выполнения задач в группе синхронно, без использования уведомления. Есть инкримент и дикримент Enter() Leave()

### Dispatch barrier
Это механизм синхронизации задач в очереди. Когда мы добавляем барьер в параллельную очередь, она откладывает выполнение задачи, помеченной барьером (и все остальные, которые поступят в очередь во время выполнения такой задачи), до тех пор, пока все предыдущие задачи не будут выполнены. После того, как все предудщие задачи будут выполнены, очередь выполнит задачу, помеченную барьером самостоятельно. Как только задача с барьером будет выполнена, очередь вернется к своему нормальному режиму работы.

### asyncAfter – метод, позволяющий отложить асинхронное выполнение задачи на определенное время.

**Проблемы** 
    * Deadlock — ситуация, в которой поток бесконечно ожидает доступ к ресурсу, который никогда не будет освобожден
    * Race condition — ситуация, в которой ожидаемый порядок выполнения операций становится непредсказуемым, в результате чего страдает закладываемая логика    

---

## Mutex
Mutex — примитив синхронизации, позволяющий захватить ресурс. Подразумевается, что как только поток обратиться к ресурсу, захваченному мьютексом, никакой другой поток не сможет с ним взаимодействовать до тех пор, пока текущий поток не освободит этот ресурс.
Стоит отметить, что mutex работает по принципу FIFO, то есть потоки будут захватывать ресурс по освобождению в том порядке, в котором данные потоки обратились к ресурсу. NSLock - более удобная реализация базового mutex из фреймворка Foundation
Reqursive mutex — разновидность базового mutex, которая позволяет потоку захватывать ресурс множество раз до тех пор, пока он не освободит его.
Condition - еще один примитив синхронизации. Задача, закрытая condition, не начнет свое выполнение до тех пор, пока не получит сигнал из другого потока. 

**Коллизия** - это когда к одному ресурсу сразу обращался несколько потоков…
Что бы этого избежать нужно использовать синхронизацию мютах(он позволяет обращаться к ресурсу только одному потому за раз…) и семафор, либо барьер в GCD
Для Thread мютах использует слова NSLock и далее вызывается переменная.lock и переменная.unlock

**Run Loop** — своего рода бесконечный цикл, предназначенный для обработки и координации всех событий, поступающих к нему на вход.
Когда Run Loop получает сообщение о событии, он запускает обработчик, ассоциированный с этим событием на своем потоке, а после выполнения усыпляет поток до следующего события, именно таким образом приложение узнает о происходящих интерактивных событиях. 

**Атомарная (греч. άτομος — неделимое) операция** — операция, которая либо выполняется целиком, либо не выполняется вовсе; операция, которая не может быть частично выполнена и частично не выполнена.

**Operation** имеет отмену, зависимости, и другие гибкие настройки.
В Swift операция (Operation) - это абстракция, используемая для управления параллельными задачами и многозадачностью, особенно в контексте многопоточности и многозадачности. Она является частью фреймворка Foundation и предоставляет удобный способ управления и выполнения задач в фоновом режиме или на разных потоках.
Операции в Swift обычно создаются путем наследования от класса Operation или его подклассов. Вы можете определить свою собственную операцию, переопределяя метод main(), который выполняет фактическую работу операции. Затем операции могут быть добавлены в очередь операций (OperationQueue), которая управляет их выполнением.
Преимущества использования операций в Swift включают в себя:
   * Управление зависимостями: Вы можете определить зависимости между операциями, что делает их выполнение более гибким и контролируемым.
    * Приоритеты: Операции могут иметь различные приоритеты, что позволяет управлять порядком выполнения задач.
    *  Отмена и приостановка: Вы можете отменить или приостановить выполнение операции в любое время.
    * Обратная связь: Вы можете использовать операции для обеспечения обратной связи между параллельными задачами.


---

## Диспетчиризация
Вызов метода -> диспетчиризация -> выполнение
Есть три метода диспетчиризации: 
* Static статическая
* Table табличная. Динамическая разделяется еще на два - V-table виртуальная  W-table витнес 
* Message сообщения 

**Direct(static)** метод: он быстрый. Но нет полиморфизма и нет наследованная. 
Используется когда метод не может быть переопределен. В расширениях, в final class. И если метод в структуре определен.
Если указать в классе final то все методы станут использовать static метод

**Table W-table** он медленнее static  нет наследованния, но есть полиморфизм.
Используется для реализации методов из протокола.

**Table V-table** он медленнее static  есть наследованния, есть полиморфизм, но затраты на компиляцию.
Используется в классах при наследовании.

**Message** 
Используется в связке с ObjC. 
Самый медленный

По дефолту у структуры статик метод, потому что структура не наследуется, и не предопределяет методы. К классов по дефолту V-Table потому что класс наследуется и может переопределять методы

---

## Keychain
**Keychain** — зашифрованная база данных, куда сохраняются небольшие объемы пользовательской информации
Keychain в Swift - это безопасное хранилище для сохранения конфиденциальных данных, таких как пароли, ключи и другие секреты, на устройствах iOS. Это может быть полезно в приложениях, где важна безопасность пользовательских данных.

У него есть несколько методов: 
Для удаления используем **SecItemDelete**.
Для Обновление элемента есть метод SecI****temUpdate.
Для получения элемента из Keychain-а используется метод **SecItemCopyMatching**.

---

## CALayer  and UIView
**CALayer** компонент для рендеринга визуального содержимого.
**UIView** контейнер для слоев CALayer который обеспечивает обработке и взаимодействие  с пользователем

---

## Обработка событий.
У **CALayer** нет средств для обработки событий таких как касание или жесты
**UIView** может обрабатывать такие события

Анимацию лучше делать через **CALayer**, так как он работает через gpu а не через процессор, что быстрее и у него более гибкие возможности для создания анимаций.

---

## Render Loop
**Render loop** — это цикл отрисовки в системе iOS.
Жизненный цикл у него такой:
    * Получаем событие
    * Создаем render tree
    * Отправляем на Render Server
    * Меняем кадр
    
### Render Server
Это отдельный процесс, который вызывает методы отрисовки для GPU с использованием OpenGL или Metal. Он отвечает за рендер наших слоев в изображение
Offscreen Rendering - по своей сути — это какие-то внеэкранный расчеты.
Под капотом это выглядит следующим образом: во время прорисовки слоя, которому необходима внеэкранные расчеты, GPU останавливает процесс визуализации и передает управление CPU. В свою очередь, CPU выполняет все необходимые операции (например, cоздает тень) и возвращает управление GPU с уже прорисованным слоем. GPU визуализирует его и процесс прорисовки продолжается.
Frame Buffer (Буфер кадров): Это основной компонент в графическом рендеринге. Frame Buffer - это область памяти, которая представляет собой изображение, которое готово к отображению на экране. В iOS, это может быть буфер, в котором хранятся графические данные для отображения на мобильном устройстве.

---

## UIKit элементы

    * UILabel: Этот элемент используется для отображения текста на экране.
    * UIButton: Кнопка, которая позволяет пользователю выполнять какие-либо действия.
    * UITextField: Поле ввода текста, где пользователь может вводить информацию.
    * UIImageView: Элемент для отображения изображений.
    * UITableView: Табличное представление, используется для отображения данных в виде таблицы.
    * UICollectionView: Похож на UITableView, но предоставляет более гибкий способ отображения данных в сетке.
    * UITabBar: Панель в нижней части экрана, которая обычно содержит навигационные элементы.
    * UINavigationBar: Панель в верхней части экрана, используется для навигации между экранами.
    * UISwitch: Переключатель, который позволяет пользователю переключать определенные параметры.
    * UIActivityIndicatorView: Индикатор активности, который отображается, когда приложение выполняет какие-либо долгие операции.
    * UIProgressView: Индикатор прогресса, используется для отображения процесса выполнения какой-либо операции.
    * UITextView: Поле для ввода многострочного текста.
    * UISlider: Ползунок, который позволяет пользователю выбирать значение в заданном диапазоне.
    * UIStepper: Элемент для увеличения или уменьшения числового значения с заданным шагом.
    * UISegmentedControl: Группа взаимосвязанных кнопок, позволяющих пользователю выбирать одну из нескольких опций.
    * UIDatePicker: Элемент для выбора даты и времени.
    * UIPickerView: Представление для выбора элемента из списка, который может быть прокручиваемым.
    * UIAlertController: Интерфейс для отображения всплывающих окон с сообщениями или диалоговыми окнами.
    * UIPageControl: Элемент для управления навигацией между страницами или контентом, например, внутри UIScrollView.
    * UIToolbar: Панель с кнопками или другими элементами управления, которая может размещаться вверху или внизу экрана.
    * UIWebView (устарел): Использовался для отображения веб-содержимого, но теперь рекомендуется использовать WKWebView.
    * UIActivityIndicatorView: Индикатор активности, который отображается, когда приложение выполняет какие-либо долгие 
    * UIPopoverController (на iPad): Элемент для отображения всплывающих окон или контроллеров.
    * UISearchBar: Элемент для добавления строки поиска в интерфейс.
    * UIRefreshControl: Элемент для обновления содержимого внутри UIScrollView или UITableView с помощью жеста "потяни, чтобы обновить".
    * UIStackView: Контейнер, который упрощает управление расположением и выравниванием других элементов интерфейса.
    * UITabBarController: Управляет размещением и навигацией между вкладками в приложении.
    * UIVisualEffectView: Позволяет добавлять различные визуальные эффекты к элементам интерфейса.
    * UIBlurEffect: Позволяет создавать размытие фона для других элементов интерфейса.

