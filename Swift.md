<h1>Swift</h1>

Оглавление:

- [Основы](#основы)
- [Базовые операторы](#базовые-операторы)
- [Хештруемые и сопоставимые данные](#хештруемые-и-сопоставимые-данные)
- [Hashable](#hashable)
- [Коллекции](#коллекции)
- [Управление потоком](#управление-потоком)
- [Регулярные выражения Regex](#регулярные-выражения)
- [Функции](#функции)
- [Замыкание](#замыкание)
- [Map ect](#map)
- [Перечисления](#перечисления)
- [Классы и структуры ](#классы-и-структуры )
- [Свойства](#свойства)
- [Методы](#методы)
- [Опциональные значения](#опциональные-значения)
- [ООП](#ооп)
- [Наследование](#наследование)
- [Инициализация](#инициализация)
- [Деинициализация](#деинициализация)
- [Обработка ошибок](#обработка-ошибок)
- [Расширения](#расширения)
- [Протоколы](#протоколы)
- [Дженерики](#дженерики)
- [ARC](#arc)
- [Тип памяти](#тип-памяти)
- [Делегирование](#делегирование)
- [Тайпкастинг](#тайпкастинг)
- [Контроль доступа](#контроль-доступа)
- [Singleton](#singleton)
- [Менеджеры зависимостей](#менеджеры-зависимостей)
- [Singleton](#singleton)
- [Жизненный цикл приложения](#жизненный-цикл-приложения)
- [Жизненный цикл ViewController](#жизненный-цикл-viewController)
- [Императивный Декларативный](#императивный-декларативный)
- [GCD задачи](#gcd-задачи)
- [User Defaults](#user-defaults)
- [Size Class](#size-class)
- [Frame Bounds](#frame-bounds)
- [UIResponder](#uiresponder)
- [Responder Chain](#responder-chain)
- [UIView](#uiview)
- [Auto Layout](#auto-layout)
- [Антипаттерн](#антипаттерн)
- [Side tables](#side-tables)
- [GCD](#gcd)
- [Mutex](#mutex)
- [Диспетчиризация](#диспетчиризация)
- [Keychain](#keychain)
- [CALayer and UIView](#calayer-and-uiview)
- [Render Loop](#render-loop)
- [UIKit элементы](#uikit-элементы)

## Основы

Можно обозначать переменные или константы в один ряд через запятую со значениями. Так же можно обозначать имена переменных в один ряд через запятую без значения, только указав тип в конце. 

    var x = 0.0, y = 0.0, z = 0.0
    var red, green, blue: Double

Имена констант и переменных не могут содержать пробелы, математические символы, стрелки, так же не могут начинаться с цифр.
Если вам нужно объявить константу или переменную тем же именем, что и зарезервированное слово Swift, то вы можете воспользоваться обратными кавычками (`) написанными вокруг этого слова. 

    let `var` = 44

$${\color{blue}print()}$$
По умолчанию функция заканчивает вывод символом переноса строки. Чтобы вывести в консоль значения без переноса на новую строку, вам нужно указать пустую строку в параметре terminator, например,

    print(someValue, terminator: "")

$${\color{blue}Различие \space между \space Double \space и \space Float}$$
* Double представляет собой 64-битное число с плавающей точкой. Используйте его когда число с плавающей точкой должно быть очень большим или чрезвычайно точным
* Float представляет собой 32-битное число с плавающей точкой. Используйте его, когда значение не нуждается в 64-битной точности.
  
$${\color{blue}Псевдонимы \space типов \space typealias}$$
Псевдонимы типов задают альтернативное имя для существующего типа. Можно задать псевдоним типа с помощью ключевого слова typealias.
Псевдонимы типов полезны, когда вы хотите обратиться к существующему типу по имени, которое больше подходит по контексту, например, когда вы работаете с данными определенного размера из внешнего источника:

    typealias AudioSample = UInt16

$${\color{blue}Отладка \space с \space помощью \space утверждений}$$

    assert(_:_:file:line:).
    let age = -3
    assert(age >= 0, "Возраст человека не может быть меньше нуля")
    
это приведет к вызову утверждения, потому что age >= 0, а указанное значение < 0.
Вызывает runtime ошибку и приложение останавливается.

> ПРИМЕЧАНИЕ Ошибка Runtime — это критическая ошибка во время выполнения программы, которая приводит к немедленной экстренной остановке работы приложения и вылету из него. Один из вариантов получить такую ошибку — принудительное извлечение опционального значения (с помощью символа !), когда в нем не содержится никакого значения (nil).

**Литеральным значением** называется значение, которое непосредственно записывается в вашем коде. Например, если вы определите переменную с именем peopleComingToEatPizza и присвоите ей значение 8, то непосредственно в исходном коде записывается значение 8. Это и есть целочисленный литерал:

    var peopleComingToEatPizza = 8


---

## Базовые операторы 
Операторы есть трех видов унарный, бинарный и тернарный.
* Унарный тот который стоит возле числа слева, например -4(минус четыре). Или восклицательный знак после буквы, например а!.
* Бинарные операторы это те у которых значения стоят слева и справа, например знак равенства = (имя переменной и его значение). Или арифметические операторы между двумя числами 10 + 10.
* Тернарный условный оператор один, он сокращает запись сравнения if else.

        let age = 35
        age > 18 ? "Можешь пить пиво" : "Иди домой сопляк"
  
$${\color{blue}Какие \space операторы \space есть:}$$
* Арифметические операторы : -+/*
* Операторы присвоения: =
* Логические операторы: &&, ||,  !
* Составные операторы: +=, -=, /=, *=
* Операторы сравнения: ==, >, <, <=, >=, !=
* Операторы диапазона или ренж (…), (..<100), (10…), (...100)

---

## Хештруемые и сопоставимые данные

* Comparable тип данных которые можно сопоставить между собой с помощью операторов <,>,=<,=>. То есть сравнить их между собой и узнать больше или меньше… **bool** нельзя сопоставить. Он не может быть больше или меньше 
* Equatable позволяет сравнить через операторы ==, !=.
* Hashable если тип данных хешируемый то значение его типа имеет свойство hashValue к которому можно обратится! 

В Swift встроена хеш функция. Хеш-функция это метод, который берет любой объект и вычисляет почти уникальное числовое представление объекта, которое может быть использовано в качестве ключа для последующего поиска. В хеш-таблицах очень быстро работает поиск O(1). Но если вам придется пройтись по связанному списку, то в худшем случае это может быть O(n)

---

## Hashable

Протокол Hashable используется для определения уникальности объекта в коллекции. Для того, чтобы тип был совместим с Hashable, он должен реализовать свойство hashValue и функцию операции равенства (==).
$${\color{teal}Хеш-функция}$$
Хеш-функция (англ. hash function от hash — превращать в фарш, мешанина), или функция свёртки — функция, осуществляющая преобразование массива входных данных произвольной длины в выходную битовую строку установленной длины, выполняемое определённым алгоритмом. Преобразование, производимое хеш-функцией, называется хешированием.
Простыми словами: Хеш-функция это метод, который берет любой объект и вычисляет почти уникальное числовое представление объекта, которое может быть использовано в качестве ключа для последующего поиска.
Хеш-таблица — это структура данных, реализующая интерфейс ассоциативного массива, а именно, она позволяет хранить пары (ключ, значение) и выполнять три операции: операцию добавления новой пары, операцию поиска и операцию удаления пары по ключу.

---

## Коллекции 

$${\color{blue}Есть \space три \space вида \space коллекций:}$$
* Массив (Array)
* Словари (Dictionary)
* Сет (Set)
  
$${\color{blue}Различия \space между \space ними:}$$
У массива есть **индекс и значение**. Для поиска значения испльзуется индекс.
У словаря **есть ключ и значение**. 
У Set есть **ТОЛЬКО** значения. 

Так же в Set и в словаре **НЕТ** постоянной последовательности, так как в них хранятся уникальные значения. В словаре не могут быть два одинаковых ключа так же как в Set не могут быть два одинаковых значения.

**Словари**: любое возвращаемое словарем значение — опционал. Если вы попытаетесь получить доступ к несуществующему элементу словаря, 
это не приведет к ошибке. Swift просто вернет nil. Свойства **keys** и **values** возвращают коллекции элементов, которые могут быть 
преобразованы в массив или множество

$${\color{blue}У \space всех \space них \space есть \space различные \space методы, \space такие \space как:}$$

* count
* isEmpty
* sorted
* reversed
* contains
* ect...

Коллекции могут быть изменяемые и неизменяемые**(let/var)**. Работают через дженерики<T>. 

**Value semantic** это референc типы которые ведут себя как тип значения!
**Array это value semantic**, он ведет себя как тип значения, но все его данные храниться в куче(heap)!!!

Set нельзя объявить упрошенным способом как массив или словарь, только через дженерик Set<Type>
В Set и в словари можно вставить только то что отвечает hashable протоколу. 

**Срезы массивов (ArraySlice)**
Дело в том, что ArraySlice не копирует исходный массив, а ссылается на его подмножество (если быть точным, то ссылается на ту же самую область памяти). Это 
сделано для экономии ресурсов компьютера, так как не создаются лишние копии 
одних и тех же данных. 

        // исходный массив
        let arrayOfNumbers = Array(1...10)
        let slice = arrayOfNumbers[4...6]
        slice // [5, 6, 7]
        // его тип данных отличается от типа исходного массива
        type(of: slice) // ArraySlice<Int>.Type

Стоит обратить внимание на то, что индексы ArraySlice соответствуют индексам 
исходной коллекции, то есть они не обязательно начинаются с 0

        // исходный массив
        arrayOfNumbers // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
        // его срез, полученный в одном из предыдущих листингов
        slice // [5, 6, 7]
        // отдельный элемент
        arrayOfNumbers[5] // 6
        slice[5] // 6 
        

**String** так же относиться к коллекции, потому что состоит из Character, и соответствует требованиям протокола Collection. 


В Swift присутствует тип данных **Substring**, описывающий подстроку некоторой 
строки. Substring для String — это как ArraySlice для Array. При получении подстроки возвращается значение типа Substring, ссылающееся на ту же область памяти, что и оригинальная строка, а это позволяет экономить ресурсы компьютера.
Другими словами, основной целью создания типа Substring была оптимизация. 
Значение типа Substring делит одну область памяти с родительской строкой, 
то есть для нее не выделяется дополнительная память.
Для получения необходимой подстроки можно воспользоваться операторами 
диапазона

       let abc = "abcdefghijklmnopqrstuvwxyz"
       // индекс первого символа
       let firstCharIndex = abc.startIndex
       // индекс четвертого символа
       let fourthCharIndex = abc.index(firstCharIndex, offsetBy:3)
       // получим подстроку
       let subAbc = abc[firstCharIndex...fourthCharIndex]
       subAbc // "abcd"
       type(of: subAbc) // Substring.Type

Нельзя получить у строки определюнную букву по средствам индекса как в массиве, это приведет к ошибке.

      str[2] // error
      
Каждый отдельный символ может быть представлен в виде юникод-скаляра.

      let anotherChar: Character = "\u{65}\u{301}"
      anotherChar // "é"

В связи с этим при работе со строковыми значениями не всегда корректным будет 
говорить именно о символах, так как мы видели ранее, что символ по своей сути 
сам может состоять из нескольких символов.

Вы не можете просто взять третий или десятый символ, так 
как нет никакой гарантии, что он окажется полноценным графем-кластером, а не 
отдельным символом в его составе. Для доступа к любому элементу коллекции 
типа **String** необходимо пройти через все предыдущие элементы. Только в этом 
случае можно однозначно получить корректный графем-кластер.
**Графем-кластер** — это совокупность юникод-скаляров (или кодовых точек), при 
визуальном представлении выглядящих как один символ. Графем-кластер может 
состоять из одного или двух юникод-скаляров. Графем-кластеры могут определять не только буквы алфавита, но и эмодзи.

Для получения нужно символа в строке нужно использовать методы:

      index(before:) 
      index(after:)
      index(_:offsetBy:) 

---

## Управление потоком


$${\color{blue}Циклы:}$$
* for in
* while

Функция **stride(from:through:by:)** возвращает последовательность числовых 
элементов, начиная с from до through с шагом by.

     for i in stride( from: 1, through: 10, by: 3 ) {
      // тело оператора
     }

Функция **stride(from:to:by:)** имеет лишь одно отличие — вместо входного параметра through используется to, который исключает указанное в нем значение 
из последовательности.

     for i in stride( from: 1, to: 10, by:3 ) {
      // тело оператора
     }

Одной из замечательных возможностей оператора for является использование 
ключевого слова where для указания дополнительных условий итерации элементов 
последовательности.

     var result = 0
     for i in 1...10 where i % 2 == 0 {
      result += i
     }
     result // 30

Или можно использовать where в for что бы избаваться от if else:

     var isRun = true
     
     // вариант 1
     if isRun {
      for i in 1...10 
      // тело оператора
      }
     }
     
     // вариант 2
     for i in 1...10 where isRun {
      // тело оператора
     }
     
$${\color{blue}Инструкции:}$$
* if
* guard
* switch
  
> Оператор **switch** выполняется быстрее. Компьютер строит специальную таблицу переходов и заранее знает, при каком условии выражения какая ветка кода должна быть выполнена. В то же время оператор if рассчитывает условия 
постепенно, одно за другим. Так, последнее условие всегда требует наибольшей работы, так как перед ним вычисляются все предыдущие.
  
Есть так же **repeat while** где условие выполняется на проверку в конце, то есть сначала будет выполнен код в repeat, а потом уже сравнивается условие. Итерации повторяются, пока 
выражение возвращает true. Его значение проверяется после каждой итерации; таким образом, тело оператора будет выполнено не менее одного раза. У **while** же, если условие вернет false уже при первой проверке, то код внутри 
оператора будет проигнорирован и не выполнен ни одного раза!

     repeat {
      // тело оператора
     } while проверяемое_выражение

В **switch** есть **case**, где можно указать все нужные параметры через запятую a, b, c и так же у case есть временные переменные и дополнительная проверка с помощью слова **where**  

    switch anotherCharacter {
    case "a", "A":
        print("The letter A")
    default:
        print("Not the letter A")
    }

    switch yetAnotherPoint {
    case let (x, y) where x == y:
        print("(\(x), \(y)) is on the line x == y")
    case let (x, y) where x == -y:
        print("(\(x), \(y)) is on the line x == -y")
    case let (x, y):
        print("(\(x), \(y)) is just some arbitrary point")
    }
        
Еще есть операторы передачи управления:   
* continue
* break
* fallthrough
* return
* throw
  
**break** прерывает цикл сразу же и выходит из него.  
**fallthrough** перенаправляет на следующую итерацию, даже если первое условие верное.

**continue** выходит из текущей итерации и передает цикл дальше к следующей итерации, не прерывая сам цикл или инструкцию.

      var x = 0
      var sum = 0
      while x <= 10 {
           x += 1
           if x % 2 == 1 {
           continue
       }
           sum += x
      }
      sum // 30

**Маркер или ярлык** нужен для того, что бы дать имя внешнему циклу для прирывания его внутри внутреннего цикла\инструкции

    имя маркера: while условие {
         исполняемый код
    }

    gameLoop: while square != finalSquare {
        diceRoll += 1
        if diceRoll == 7 { diceRoll = 1 }
        switch square + diceRoll {
        case finalSquare:
            //после броска кубика мы попадаем на клетку 25, игра окончена
            break gameLoop
        case let newSquare where newSquare > finalSquare:
             //мы кинули кубик на слишком большое значение, значит нам нужно кинуть снова
            continue gameLoop
        default:
            //допустимое движение по игровому полю, двигаемся
            square += diceRoll
            square += board[square]
        }
    }
    print("Game over!")
    
---

## Регулярные выражения
Регулярные выражения позволяют нам выполнять сложные операции поиска и замены в тысячах текстовых файлов всего за несколько секунд. 
Regex по сути он помогает проверить на валидность нужное тебе выражение, почту, строку и тд. Указываешь нужные параметры и готово. 

---

## Функции 
**Функция** это отдельный блок кода, который выполняет определенную задачу. Она вызывается в нужном месте и в нужное время. 
У нее есть параметры для работы. Количество параметров не ограничено. У параметров есть внешние имена и внутренние.  
Так же в параметры можно передать значения по умолчанию через знак равно(=).

$${\color{blue}Вариативные \space параметры}$$
Еще есть вариативный параметры(три точки) которые можно указать после типа параметра, что бы он принимал при вызове функции сразу много значений, и тогда это сразу превратится массив… Можно использовать только один параметр в данной функции или несколько, но тогда нужно внешнее имя для второго вариативного параметра,то есть ярлык 

    func arithmeticMean(int: Int..., sumForDouble numbers: Double...) -> Double {}
    
$${\color{blue}Сквозные \space параметры}$$
Параметры функции по умолчанию являются константами. Так как в функции нельзя изменять внешнюю переменную, ведь в функцию передается копия переданных данных, то для обхода данного фишки можно использовать ключевое слово **inout** перед типом. И тогда функция сможет изменять переменную, но не забудь добавить знак амперсанта **&** в передаваемых параметрах функции во время вызова.
Сквозные параметры не могут иметь значения по умолчанию, а вариативные параметры не могут быть сквозными, с ключевым словом inout.

     func changeValues(_ a: inout Int, _ b: inout Int) -> Void {
      let tmp = a
      a = b
      b = tmp
     }
     var x = 150, y = 45
     changeValues(&x, &y)
     x // 45
     y // 150

$${\color{blue}Higher-order \space functions \space (Функции высшего порядка):}$$
Это функции, которые вы передаете в качестве аргументов другим функциям. В этом простом примере, фильтр требует передачи функции высшего порядка.

$${\color{blue}Сложный \space функциональный \space тип}$$  

В некоторых случаях выходное значение функции также является функцией, 
которая, в свою очередь, может возвращать значение. В результате этого функциональный тип становится сложным, то есть содержащим несколько указателей 
на возвращаемое значение (несколько стрелок ->).
В самом простом варианте функция, возвращающая другую функцию, которая 
ничего не возвращает, будет иметь следующий функциональный тип:

    () -> () -> Void

$${\color{blue}Перегрузка \space функций}$$  

Swift позволяет перегружать функции (overloading), то есть в одной и той же 
области видимости создавать функции с одинаковыми имenumи. Различия функций должны заключаться в их функциональных типах (входных и выходных 
параметрах)

    func say(what: String) -> Void {}
    func say(what: Int) -> Void {}

У данных функций одно и то же имя say(what:), один и тот же тип возвращаемого 
значения, но различные типы входных параметров. В результате Swift определяет 
обе функции как различные и позволяет им сосуществовать одновременно. Это 
связано с тем, что функциональный тип первой функции (String) -> Void, а второй — (Int) -> Void.


---

## Замыкание
Ссылочный тип. Отдельный блок кода который можно вызвать в нужном месте.
Проще говоря, замыкание это как небольшая анонимная(безимянная) функция, которая может быть передана другой функции, переменной или использована самостоятельно.

$${\color{blue}Completion \space handler}$$ 

* По умолчанию все переданные в функцию замыкания имеют ограниченную этой функцией область видимости, то есть если вы решите сохранить замыкание для дальнейшего использования, то встретитесь с определенными трудностями. 
* Другими словами, все переданные в функцию замыкания являются не выходящими за пределы ее тела. Если Swift видит, что область, где замыкание доступно, ограничена, он при первой же возможности удалит его, чтобы освободить и не расходовать оперативную память.
* Для того чтобы позволить замыканию выйти за пределы области видимости функции, необходимо указать атрибут @escaping перед функциональным типом при описании входных параметров функции.

Completion handler с атрибутом @escaping это специальный тип замыкания (closure) в Swift, который указывает на то, что это замыкание может "выбраться" (escape) из текущей области видимости и продолжить своё выполнение после завершения функции, в которой оно было передано. То есть при сетевых запросах мы вызываем Completion handler для того, что бы выполнить какие то определение действия после завершения получения данных из сети.
Нужно для асинхронного запроса. Вызовется в конце работы функции. Все опциональные замыкание по дефолту @escaping.

Распространенным применением замыканий является обработчик завершения.
    •    Вы выполняете длительную по времени задачу в своем коде, например, загружаете файл, делаете расчет или ждете ответа веб-сервиса.
    •    Вы хотите выполнить некоторый код, когда долгая задача будет завершена, но вы не хотите постоянно выяснять статус, чтобы узнать, завершена ли она.
    •    Вместо этого вы предоставляете замыкание для долгой задачи, которое будет вызвано, когда задача будет завершена (отсюда название обработчик завершения).

В сокращенной форме записи имен входных параметров обозначение $0
указывает на первый передаваемый аргумент. Для доступа ко второму аргументу необходимо 
использовать обозначение $1, к третьему — $2 и т. д.

$${\color{blue}Вынос \space замыкания \space за \space скобки}$$ 
   
Если входной параметр функции расположен последним в списке входных параметров функции **(как в данном случае в функции handle(wallet:closure:)**, где параметр closure является последним), Swift позволяет вынести его значение (тело замыкающего выражения) за круглые скобки.

    handle(wallet: wallet){ $0 >= 1000 }

Входные параметры замыкания не должны иметь внешних имен. По этой причине в первом случае указание имени вообще отсутствует, а во втором используется знак нижнего подчеркивания.

    let closurePrint: (String) -> Void = { text in
        print(text)
    }
    closurePrint("Text")
    
    var sum: (_ numOne: Int, _ numTwo: Int) -> Int = {
        $0 + $1
    }
    sum(10, 34) // 44


$${\color{blue}Захват \space переменных}$$ 
Swift позволяет зафиксировать значения внешних по отношению к замыканию параметров, которые они имели на момент его определения. Существуют два параметра, a и b, которые не передаются в качестве аргументов в замыкание, но используются им в вычислениях. При каждом вызове такого замыкания оно будет определять значения данных параметров, прежде чем приступить к выполнению операции с их участием.

    var a = 1
    var b = 2
    let closureSum : () -> Int = {
     a + b
    }
    closureSum() // 3
    a = 3
    b = 4
    closureSum() // 7

Существует способ захватить значения параметров, то есть зафиксировать те значения, которые имеют эти параметры на момент объявления замыкающего выражения. Для этого в начале замыкания в квадратных скобках необходимо перечислить захватываемые переменные, разделив их запятой, после чего указать ключевое слово in.

    var a = 1
    var b = 2
    let closureSum : () -> Int = { [a, b] in
     a + b
    }
    closureSum() // 3
     a = 3
     b = 4
    closureSum() // 3

---

## Map

* Метод map(_:) позволяет применить переданное в него замыкание для каждого элемента коллекции. В результате его выполнения возвращается новая последовательность, тип элементов которой может отличаться от типа исходных элементов.
 
      var newArray = array.map{$0} 

* Метод mapValues(_:) позволяет обработать значения каждого элемента словаря,при этом ключи элементов останутся в исходном состоянии.
  
      let mappedCloseStars = ["Proxima Centauri": 4.24, "Alpha Centauri A": 4.37]
      let newCollection = mappedCloseStars.mapValues{ $0+1 }
      newCollection // ["Proxima Centauri": "5.24", "Alpha Centauri A": "5.37]


* Метод flatMap(_:) отличается от map(_:) тем, что всегда возвращает плоский одномерный массив. Так, пример, приведенный в листинге 14.4, но с использованием flatMap(_:), вернет одномерный массив.

      let numbersArray = [1, 2, 3, 4]
      let flatMapped = numbersArray.flatMap { Array(repeating: $0, count: $0) }
      flatMapped // [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]

      let someArray = [[1, 2, 3, 4, 5], [11, 44, 1, 6], [16, 403, 321, 10]]
      let filterSomeArray = someArray.flatMap{$0.filter{ $0 % 2 == 0}}
      filterSomeArray // [2, 4, 44, 6, 16, 10]

* Метод compactMap(_:) позволяет произвести те же действия, что и map(_:), разница лишь в реакции на ситуацию, когда преобразование не может быть произведено. В листинге 14.9 показан пример преобразования массива строковых значений в массив значений типа Int. Как видно из значения константы intFromStringArray, при неудачной попытке преобразования String в Int в результирующий массив помещается специальное ключевое слово nil.Если воспользоваться методом compactMap(_:), то все неуспешные преобразования будут проигнорированы и исключены из результата.

      let stringArray = ["1", "2", "3", "four", "5"]
      let intFromStringArray = stringArray.map() { Int($0) }
      intFromStringArray // [1, 2, 3, nil, 5]
 
      let arrayWitoutNil = stringArray.compactMap() { Int($0) }
      arrayWitoutNil // [1, 2, 3, 5]

* Метод filter(_:) используется, когда требуется отфильтровать элементы коллекции по определенному правилу.

      let numArray = [1, 4, 10, 15]
      let even = numArray.filter{ $0 % 2 == 0 }
      even // [4, 10]

* Метод reduce(_:_:) позволяет объедinitь все элементы коллекции в одно значение в соответствии с переданным замыканием.

      let cash = [10, 50, 100, 500]
      let total = cash.reduce(210, +) // 870

* Функция zip(_:_:) предназначена для формирования последовательности пар значений, каждая из которых составлена из элементов двух базовых последовательностей. Другими словами, если у вас есть две последовательности и вам нужно попарно брать их элементы, группировать и складывать в новую последовательность, то эта функция как раз то, что нужно. Сначала вы берете первые элементы каждой последовательности, группируете их, потом берете вторые элементы, и т. д

      let collectionOne = [1, 2, 3]
      let collectionTwo = [4, 5, 6]
      let zipSequence = zip(collectionOne, collectionTwo)
      type(of: zipSequence) // Zip2Sequence<Array<Int>, Array<Int>>.Type
  
      Array(zipSequence) // [(.0 1, .1 4), (.0 2, .1 5), (.0 3, .1 6)]
  
      let newDictionary = Dictionary(uniqueKeysWithValues: zipSequence)
      newDictionary // [1: 4, 3: 6, 2: 5]

---

## Перечисления
Enum это конечное множество. Помогает сократить количество ошибок при выборе или вводе какой то информации.

Перечисления используют **тип значения**, работают в стеке. У них есть кейсы(case) и есть функции. Так же есть сырое значение (rawValue) которе принимает имя Кайса за значение этого кейса при необходимости. Так же ест caseIteration который позволяет посчитать все кейсы и пройтись по ним в цикле. Еще есть ассоциативное значение у кексов. 

---

## Классы и структуры 

$${\color{blue}actor \space про \space акторы}$$ 

Акторы работают как классы, не считая того, что они могут безопасно использоваться при **параллельном выполнении**. Что это означает? Swift всеми силами старается гарантировать, что данные внутри актора не могут быть изменены в то время, когда что-то другое пытается сделать то же самое. Эта проблема довольно типична для параллельного выполнения. Акторы очень похожи на классы и структуры, они также могут содержать свойства и методы. И они, как и классы, являются ссылочными типами, так что у них больше общего с классами, нежели со структурами.

    actor Human {
        var maximumAge = 107
        
        func printAge() {
            print(“Max age is currently \(maximumAge)”)
        }
    }
    
Представьте, что ему потребовалось обновить значение maximumAge на основании данных другого актора Human, который прожил дольше максимума. Вот как это безопасно делается для акторов:

    func updateMaximumAge(from other: Human) async {
        maximumAge = await other.maximumAge
    }

Ключевые слова aysnc и await фактически сообщают Swift, что вы хотите отправить быстрое сообщение другим экземплярам Human и предложить им сообщить значение maximumAge при первой возможности. Это может произойти немедленно, а может произойти по прошествии заметного времени. При таком подходе с ними можно безопасно работать.

Ключевые моменты:
* Акторы похожи на классы, но они проектировались для параллельного выполнения и безопасности.
* При помощи ключевых слов async и await акторы могут безопасно запрашивать данные от других данных в условиях параллельного выполнения.
* Создавая актор, вы можете делать с его свойствами все что угодно, но если вам понадобится взаимодействовать с другим типом, необходимо использовать async и await для обеспечения безопасности. Это связано с тем, что акторы гарантируют безопасность в условиях параллельного выполнения.


$${\color{blue}Классы \space и \space структуры}$$ 

* Классы это **ссылочный тип**. 
* Структуры, enumы и базовые типы это **тип значения**.


При создании класса используется **куча**, а у структуры используется **стек**. Указатели(ссылки, для классов) хранятся **в стеке для ссылочного типа**.

Все типы в Swift работают как **типы значения**. Кроме функций, акторов и кложеров, они работают как ссылочный тип. 

**Сценарии когда тип значение лежит не в стеке это когда внутри типа значение лежит ссылочный тип.**

$${\color{blue}Отличия \space классов \space и \space структур}$$ 
* У структуры встроен по умолчанию инициализатор, у классов нет автоматического инициализатора.
* Структура работает через стек, класс работает через кучу **(сслыки хранятся в стеке)**.
* Класс можно наследовать(у класса нет множественного наследования), структура не наследуется.
* Свойство-переменную можно изменить в классе-константе, но не в структуре-константе.
* У класса имеется деинициализатор, который вызывается при его уничтожении. У структуры деинициализатора нет.
  
Классы и структуры имеют свойства и методы. 
Структуры и enumы не могут через свои методы изменять свои же свойства из-за того, что это тип значения, только если перед методом поставить слово **mutating**. Класс же может изменять в методе свои же свойства.

> Одного использования ключевого слова mutating достаточно, чтобы Swift не позволил вам использовать этот метод со **структурами-константами**. Swift верит вам на слово, что это изменяющий метод. Таким образом, даже если метод вообще не обращается к свойствам, вы не сможете вызвать его для структуры, которая была создана как **константа**.


$${\color{blue}Изменяемость}$$  
Экземпляр класса может изменять значения своих свойств, объявленных как переменная (var), даже если сам экземпляр хранится в константе(let). При этом использовать ключевое слово **mutating** для методов не требуется.

Если у вас есть класс с большим количеством методов, но вам нужно наследовать только небольшую часть из них, рекомендуется использовать **композицию** или **агрегацию** вместо наследования.

      class MyFunctionality {
          func method1() {
              // ...
          }
          func method2() {
              // ...
          }
          // ... множество других методов ...
      }
      
      class Subclass {
          private let functionality = MyFunctionality()
          
          func method1() {
              functionality.method1()
          }
          
          // ... только нужные методы ...
      }

     
$${\color{blue}Правила \space выбора \space между \space классом \space и \space структурой}$$ 

При создании очередной сущности в вашем приложении придерживайтесь следующих правил:
* Правило № 1 Отдавайте предпочтение структурам, нежели классам.
* Правило № 2 Используйте классы только тогда, когда вам действительно нужны их особенности.

**Причина выбрать структуру № 1. Безопасность**
Структуры безопаснее классов. Множественные копии объекта, в отличие от множественных ссылок, не способны привести к случайному, неконтролируемому изменению данных. 

**Причина выбрать структуру № 2. Утечки памяти**
В главе об управлении памятью нами был разобран пример утечки памяти. При использовании структур такая проблема исчезает, опять же по причине того, что значения передаются копией, а не в виде ссылки.

**Причина выбрать структуру № 3. Раздутые объектные типы**
Swift не поддерживает множественное наследование. Таким образом, у вас отсутствует возможность создать класс — наследник нескольких родительских классов. И как уже отмечалось, для структур наследование вообще недоступно. Это побуждает создавать огромные раздутые типы-комбайны, которые одновременно способны решать большое количество задач. Создание комбайнов является плохим приемом программирования.

**Причина выбрать структуру № 4. Структуры быстрее классов**
Некий код*
Как вы можете видеть из вывода на консоли, выполнение операций со структурой происходит в 60 раз быстрее, чем с классом. Причина этого кроется в организации хранения и доступа к классам и структурам в памяти компьютера.

> Все вышесказанное не означает, что вы всегда должны использовать структуры. Классы существуют не просто ради того, чтобы они были, у них также есть своя область применения.

**Причина выбрать класс № 1. Логичная передача объекта по ссылке**
Стоит использовать класс в тех случаях, когда однозначно понятно, что лучше передавать объект по ссылке, нежели копировать его. Примерами могут служить файловые дескрипторы и сетевые подключения, открытые в ваших приложениях.

**Причина выбрать класс № 2. Совместимость c Objective-C**
Если на ваши плечи ляжет необходимость поддержки старых проектов, написанных на Objective-C, или использования старых библиотек, то классы станут вашим верным другом.

---

## Свойства
Они бывают следующими: 
* Хранимые свойства
* Вычисляемые свойства
* Ленивые свойства
* Наблюдатели
* Свойства типа(static).

При чем свойства **хранения** отсутствуют в enum. 
Свойства **вычисления** используют **гетер и сетер**, если установлен только гетер, то это вычисляемое свойство для чтения, без установки нового значения. 

$${\color{blue}Наблюдатели \space хранимых \space свойств}$$ 
Наблюдатели — это специальные функции, которые вызываются либо непосредственно перед установкой нового значения хранимого свойства, либо сразу после нее.
* Наблюдатель **willSet** вызывается перед установкой нового значения.
* Наблюдатель **didSet** вызывается после установки нового значения.

При объявлении наблюдателей можно использовать сокращенный синтаксис, в котором не требуется указывать входные аргументы (точно так же, как сокращенный синтаксис сеттера). При этом новое значение в willSet присваивается параметру newValue, а старое в didSet — параметру oldValue.

    var имяСвойства: ТипЗначения {
        willSet (ассоциированныйПараметр) {
        // тело обсервера
        }
        didSet (ассоциированныйПараметр) {
        // тело обсервера
        }
    }

$${\color{blue}Lazy \space свойства}$$ 
Ленивые свойства вызываются только тогда, когда к ним обратятся, при инициализации они не вызываются. Lazy свойства могут быть только хранимыми, потому что они должны иметь значение до инициализации. То есть они не могут быть методом или вычисляемым свойством. 
Существует два типа ленивых элементов:
 lazy-by-name — значение элемента вычисляется при каждом обращении к нему;
 lazy-by-need — элемент вычисляется один раз при первом обращении к нему, 
после чего фиксируется и больше не изменяется.
Можно сказать, что любая функция или метод являются lazy-by-name, так как их значение высчитывается при каждом обращении.

Так же свойства наблюдатели не вызываются при инициализации, только когда к ним обратятся.

При создании класса, память не используется, так как при создании класса идет лишь описание его, но не инициализация. Память устройства испльзуется только при создании объекта. 

$${\color{blue}Различие \space между \space объектом \space и \space классом}$$ 
* Объект занимает место в памяти, через объект можно обратиться к свойствам или методам класса, его можно менять.
* Класс же не занимает помять, не дает возможность с ним взаимодействовать и изменять его.

Свойство типа(static) позволяет обратится к свойству класса не создавая объекта в памяти устройства через слово **static**. 

    struct Pizza {
        var name: String
        var ingredients: [String]
        var dessertPizza: Bool
        static var count = 0
        
        init() {
            name = "Cheese"
            ingredients = ["Cheese"]
            dessertPizza = false
            Pizza.count += 1
        }
        
        init(name: String, ingredients: [String], dessertPizza: Bool) {
            self.name = name
            self.ingredients = ingredients
            self.dessertPizza = dessertPizza
            Pizza.count += 1
        }
    }
    
    var pizza1 = Pizza()
    var pizza2 = Pizza()
    print(Pizza.count) // 2

**Свойство count принадлежит самой структуре,а не ее отдельным экземплярам, поэтому мы обращаемся к нему по имени структуры Pizza.**


**Различие между static и class** 
class: Этот модификатор может быть применен только к свойствам и методам в классах. В отличие от static, свойство или метод с модификатором class может быть унаследован и переопределен в подклассах. Модификатор class не может быть у хранимого свойства, только у вычисляемого метода. class не применяется к хранимым свойствам, потому что они не имеют логики, которая может быть переопределена в подклассах. 

**Структуры не могут быть синглтонами.**

---

## Методы 
Методы так же могут как и свойства использовать слова static для определения метода без указания экземпляра. Так же в структуре и enumе методы не могут менять значение свойств без слова mutating. Методы так же имею параметры и возвращаемое значение как и обычные функции. Внутри метода неявно указывается self.  Структура может изменять значения свойств только в том случае, если экземпляр структуры хранится в переменной(var).

    struct ChessPlayer {
        var name: String = "Игрок"
        var victories: UInt = 0
        init(name: String) {
            self.name = name
        }
        func description() {
            print("Игрок \(name) имеет \(victories) побед")
        }
        mutating func addVictories( count: UInt = 1 ) {
            victories += count
        }
    }

---

## Опциональные значения
Опционалы нужны для предоставления возможности отсутствие значения где либо, например в переменной. Если рядом с типом поставить вопросительный знак, значит это уже будет другой тип, но с опциональным значением. Сравнивать Int и Int? Нельзя, так как это разные типы.

$${\color{blue}Бывают \space несколько \space опциональных \space значений:}$$    

* **Force Unwrap** которое извлекает опциональное значение принудительно через восклицательный знак !. 
* **Optional binding** который позволяет извлекать безопасно опциональные значения. Для этого используется **if let или guard let**. При этом можно задать значение или вывести в консоль что либо при значении nil в переменной после извлечения, через else. 
* **Optional chaining** когда  например при сложении обычной переменной и опциональной переменной ставиться вопросительный знак для опциональной переменной без безопасного извлечения. 
* **Implicitly Unwrapped Optionals** когда в опциональном типе ставиться восклицательный знак ! вместо вопросительного, тем самым как бы утверждая, что данные тут точно есть и можно их извлекать до первого обращения к нему. 
* **Nil-coalescing operator** который предоставляет значение по умолчанию для опцианальной переменной используя два вопросительных знака ??.


Устроены опционалы как enum с двумя case в которых лежат два значения. В одном nil в другом value которе присватывается через ассоциативное значение используя <T> дженерики.

    enum Optional<Wrapped> {
        case none
        case some(Wrapped)
    }


СИНТАКСИС
* Полная форма записи: **Optional<T>**
* Краткая форма записи:**T?**
  
     let optionalChar: Optional<Character> = "a"
  
     var xCoordinate: Int? = 12


Если объявить переменную опционального типа, но не проинициализировать ее 
значение, Swift по умолчанию сочтет ее равной nil
Для создания опционала помимо явного указания типа также можно использовать функцию **Optional(_:)**

     // опциональная переменная с установленным значением
     var optionalVar = Optional("stringValue") // "stringValue"
     // уничтожаем значение опциональной переменной
     optionalVar = nil // nil
     type(of: optionalVar) // Optional<String>.Type

---

## ООП

**Про ПОП**
> ПОП основан на ООП, но на данный момент не имеет четкого и конкретного описания. Впервые об этой методологии упомянули на конференции WWDC 15, где Swift был назван первым протокол-ориентированным языком в истории программирования. Но зачем? Почему Swift не может в полной мере использовать старый добрый объектно-ориентированный подход? На то есть две основные причины.
> Причина № 1. В Swift отсутствует множественное наследование. Классы могут наследоваться только от одного родителя, а структуры вообще не могут иметь родительские объектные типы. Но при этом у вас есть возможность подписывать классы и структуры на множество протоколов.
> Причина № 2. Протоколы позволяют содержать реализацию по умолчанию. В Swift протокол может быть не просто набором требований, но также содержать их реализацию. Таким образом, мы можем создать множество протоколов, при необходимости указать реализацию по умолчанию и при создании объектного типа подписать его на данные протоколы, с ходу обеспечив тип функциональной составляющей. 

> Суть протокол-ориентированного программирования состоит в том, что в первую очередь описываются протоколы, а уже потом объектные типы, принимающие их к реализации.


**ООП** это методология программирования, что проставляет программу на взаимодействие объектов, которые являются экземплярами определенных классов, а классы образуют иерархию наследования.

Принцыпы: ПИНа 
* Полиморфизм это когда один интерфейс но много реализаций. Когда класс делает, что то но с различными методами. Например класс Auto, он едет. Но реализация может быть разной, он может ехать быстро, медленно, удобно, или не очень. Та функция которая принимает  данный класс,  должна без проблем реализовать его работу, несмотря на различные методы. То если класс User принимает в свой метод drive класс Auto то все должно работать без проблем. 
* Инкапсуляция когда скрываешь реализацию от чужих глаз. То есть ты прячем саму реализацию от изменений. Иногда можно считать данные, но не менять реализацию. Пример то как работает двигатель скрыт от водителя, он инкапсулирован. Но его можно использовать что бы авто двигалось вперед.
* Наслелование каждый наследуемый(подкласс) класс должен уметь делать все то, что умеет делать родительский класс.
* Абстракция это когда вместо класса авто, мы используем транспортное средство. Это нужно для расширения программы. Например у нас есть компания по доставке товаров. И по началу мы на доставку использовали только авто(класс  AUTO). Если компания вырастет, то надо будет доставлять товар и самолетом и поездом и тд. То есть класс АВТО уже не абстрактный, он привязан к определенным вещам и реализациям.

Парадигма программирования — это совокупность идей, определяющих стиль написания программного кода. Другими словами, парадигма говорит, каким образом необходимо организовать свой программный код и как его организация будет влиять на ход вычислений при решении задач вашим приложением.

$${\color{blue}Парадигмы \space программирования}$$ 

* Императивное 
* Процедурное
* Структурное
* Функциональное 
* ООП объекто ориентированное программирование
* ПОП протоколо ориентированное программирование 
* Реактивное 

---
 
## Наследование
Наследование работает только с классами. Подклассы имею доступ ко всем свойствам и методам суперкласса. Подклассы могут наследовать от других подклассов. Тогда они будет иметь все свойства идущие по всей цепочке иерархии от суперкласса, до подкласса. Можно так же использовать супер класс как ТИП для экземпляров класса которые наследовали от суперкласса или подкласса в цикле, массиве и тд.
Подклассы могут переопределять свойства и методы супер класса с помощью слова override. Что бы запретить переопределение, нужно использовать слово final перед свойствами или методами, а так же можно запретить наследованная от супер класса написав final class. 
Можно переопределить хранимые свойства добавлением гет сет, так же и у вычисляемых свойств. Нельзя переопределись константы let и только читаемые вычисляемые свойства. Должно быть гет сет. 

### Минусы наследование.
Почему? Потому что глубокая иерархия наследованная, и если будет баг в середине этой цепочки, то непонятно куда идти, вверх или вниз по цепочке.
Нет множественного наследованная. По этой причине при изменении в методе чего либо влияет на его потомком. Можно решить множественное наследованные с помощью протоколов, тот же Codable. 

---

## Инициализация

> Инициализатор (конструктор) — это специальный метод, выполняющий подготовительные действия при создании экземпляра объектного типа данных. Инициализатор срабатывает при создании экземпляра, а при его удалении вызывается деинициализатор. Инициализатор выполняет установку начальных значений хранимых свойстви различных настроек, которые нужны для использования экземпляра.

**классы и структуры имеют встроенные инициализаторы:**
* классы имеют пустой встроенный инициализатор init(){};
* структуры имеют встроенный инициализатор, принимающий в качестве входных аргументов значения всех свойств.

> ПРИМЕЧАНИЕ Пустой инициализатор срабатывает без ошибок только в том случае, если у класса отсутствуют свойства или у каждого свойства указано значение по умолчанию.

Инициализация это когда устанавливаются свойства, а не объект. Задачи init установить все хранимые свойства для гарантии работы объекта. Это подготовительный процесс экземпляра класса и установка начальных значений свойств. 
В инициализации нельзя вызвать метод, пока не будут указаны все свойства что есть в классе.
Если установленные значения по умолчанию для свойств, то в init при сознании экземпляра не обязательно устанавливать значения для свойств. Даже сам init не надо писать. Если по умолчанию опциональное свойство, то его значение равно nil.

    class ShoppingListItem {
        var name: String?
        var quantity = 1
        var purchased = false
    }
    var item = ShoppingListItem()

В структуре что бы не пропал инициализатор по умолчанию создав свой init внутри структуры, надо создать init в extention, тогда при создании экземпляра init останется в структуре.
Только в Классе есть два init : основной это Дизигнейтед(Назначенные) и Конвиниент(Вспомогательные)(пишется впереди слова init) нужен для того, что бы из дополнительного init отправлять данные в другой init.
Методы не могут быть вызваны в initе перед свойствами, только после инициализации всех свойств, и супер.init тоже.  

> Инициализаторы класса и структуры, производящие установку значений свойств, называются назначенными (designated). Вы можете разработать произвольное количество назначенных инициализаторов с отличающимся набором параметров в пределах одного объектного типа. При этом должен существовать хотя бы один назначенный инициализатор, производящий установку значений всех свойств (если они существуют), и один из назначенных инициализаторов должен обязательно вызываться при создании экземпляра.

> Помимо назначенных, в Swift существуют вспомогательные (convenience) инициализаторы. Они являются вторичными и поддерживающими. Вы можете определить вспомогательный инициализатор для проведения настроек и обязательного вызова одного из назначенных инициализаторов. Вспомогательные инициализаторы не являются обязательными для их реализации в типе. Создавайте их, если это обеспечивает наиболее рациональный путь решения поставленной задачи.

    class Dog: Quadruped {
        override init() {
            super.init()
            self.type = "dog"
        }
        convenience init(text: String) {
            self.init()
            print(text)
        }
        func bark() {
            print("woof")
        }
        func printName() {
            print(self.name)
        }
    }
    var someDog = Dog(text: "Экземпляр класса Dog создан")

В результате при создании нового экземпляра класса Dog вам будет предложено выбрать один из двух инициализаторов: init() или init(text:). Вспомогательный инициализатор вызывает назначенный и выводит текст на консоль.

    init(language: String = "Swift") {
            self.language = language
            super.init(name: "UNKNOWN", salary: 100)
            addSalary()
        }
        
* Правило номер 1. Нельзя вызвать в дезигнейтед init супер.конвиниет init, только дезигнейтед…
* Правило номер 2. Если вызываешь один init в другом , то должен использовать слово конвиниент init
* Правило номер 3. Если вызываешь конвиниет init, то последним должен быть обязательно только дезигрейтед init, даже если конвиниет будет вызывать еще несколько конвиниентов.

Как произсходит инициализация. Если в наследнике вызвать супер.init то он сначала проинициализирует свои свойства, далее пойдет к супер классу, произведет там инициализацию свойств, изменит если что то там было во второй фазе, и уже после этого вернется к наследнику для изменений свойств в initе, вторая фаза будет. Первая фаза инициализация всех свойств, вторая фаза это изменения свойств.

Есть так же **fallible init?**(Проваливающийся инициализатор) Который отмечается знаком вопроса после слова init и он возвращает nil если какие то условия указаны в самом initе. Через ту же проверку guard else или if 
Если вы добавите такой инициализатор в структуру Shape, он может возвращать nil при попытке создания экземпляра Shape с менее чем 3 сторонами:

    struct Shape {
        var sides: Int
    
        init?(sides: Int) {
            guard sides >= 3 else { return nil }
            self.sides = sides
        }

        func printShape() {
            print("Shape has \(sides) sides.")
        }
    }
    
    //Теперь в программе можно безопасно создавать как действительные, так и недействительные фигуры:

    var box = Shape(sides: 4) // Optional<Shape> (с 4 сторонами)
    var triangle = Shape(sides: 3) // Optional<Shape> (с 3 сторонами) 
    var triquandle = Shape(sides: -4) // nil
    

Так же есть **required init**(требуемые инициализоторы) который указывается в суперкласс, что бы он был обязательно вызвал в подклассе. Причем если его не вызвать, то будет ошибка. Так же в подклассе в required init надо будет удалить строчку fatalError что бы программа не сломалась в runTime. Нужно туда вписать корректные и нужные параметры.

Начальное значение свойства в виде замыкания. после закрывающей фигурной скобки замыкания идут пустая пара круглых скобок. Это означает, что нужно исполнить это замыкание немедленно. 

    class SomeClass {
        let someProperty: SomeType = {
          // создаем начальное значения для SomeProperty внутри этого замыкания
          // someValue должен быть того же типа, что и SomeType
          return someValue
        }()
    } 


**Доп инфа:**

$${\color{blue}Проваливающиеся \space инициализаторы}$$ 
 
В некоторых ситуациях бывает необходимо определить объектный тип, создание экземпляра которого может закончиться неудачей, вызванной некорректным набором внешних параметров, отсутствием какого-либо внешнего ресурса или иным обстоятельством. Для этой цели служат проваливающиеся (failable) инициализаторы. Они способны возвращать nil при попытке создания экземпляра. И это их основное предназначение. В теле инициализатора должно присутствовать выражение return nil. Для создания проваливающегося инициализатора служит ключевое слово init? (со знаком вопроса), который говорит о том, что возвращаемый экземпляр будет опционалом или его не будет вовсе.

    init?(параметры) {
    // тело инициализатора
    return nil
    }


$${\color{blue}Обязательные \space инициализаторы}$$ 
Обязательный (required) инициализатор — это инициализатор, который обязательно должен быть определен во всех подклассах данного класса. Для объявления обязательного инициализатора перед ключевым словом init указывается модификатор required. Кроме того, модификатор required необходимо указывать перед каждой реализацией данного инициализатора в подклассах, чтобы последующие подклассы также реализовывали этот инициализатор.

    required init(параметры) {
    // тело инициализатора
    }

    
---

## Деинициализация

> Деинициализатор (деструктор) — это специальный метод, который автоматически вызывается во время уничтожения экземпляра класса. Вы не можете вызвать деинициализатор самостоятельно. Один класс может иметь не более одного деинициализатора. ПРИМЕЧАНИЕ Деинициализаторы являются отличительной особенностью классов и недоступны для структур.

Деинилизация нужна для того, что бы освободить зарезервированную память от экземпляра класса. То есть идет подготовка к высвобождению памяти.
**Она может быть только у класса, только.**

После выхода из области видимости, то есть из скобок do {} или func {} объект умирает. 
Так же что бы не исползать область видимости, можно привести экземпляр к опциональному типу и установить nil.

    class Boomb {
        var damage: Double = 50
        
    deinit {
        print(Освободил память Booooom)      }
    }
    var boomb: Boomb? = Boomb (V
    boomb = nil


Чтобы убедиться в том, что деинициализатор выполняется, можно воспользоваться ключевым словом _ и создать экземпляр Plant (который будет немедленно уничтожен, потому что так работает синтаксис _):

    var _ = Plant(name: "Bay laurel", latinName: "Laurus nobilis", type: "Evergreen Tree")

    //The plant 'Bay laurel' has been deinitialized.

При наследовании, освобождается **сначала подкласс**, а после уже супер класс(всплытие так сказать от подкласса до супер класса)
Определения класса могут иметь максимум один деинициализатор на один класс. Деинициализатор не принимает ни одного параметра и пишется без круглых скобок.

---

## Обработка ошибок
Это нужно, что бы понимать какая ошибка произошла, и соответствующим образом изменить код!
Для того чтобы сгенерировать ошибку, вы используете инструкцию throw. 
Используется для обработки ошибок при работе с сетью… 
В функции пишется throws и дальше помечаются ошибки словом throw. 
Обрабатывать ошибки могут функции, методы и инициализаторы

Обработка ошибки должно происходить в блоке do catch и словом try

**Try** всегда пишется в блоке do-catch иначе будет ошибка.

Если функция реализует ошибку do-catch то она должны в catch использовать все возможные варианты ошибок, и для этого нужно дополнительно указать catch без указания enumа с ошибками. Либо не писать последний catch и и указать в конце функции слово thows.

**Defer**
Вы используете оператор defer для выполнения набора инструкций перед тем как исполнение кода оставит текущий блок. Это позволяет сделать любую необходимую очистку. Он выполниться после return и перед выходом из области видимости… пишется обычно в начале области видимости. Если указаны несколько defer то они выполняться в обратном порядке, снизу вверх: вот пример 

    func deferTest() -> Strina {
            var currentString = 
            currentString += "A"
        
        defer {
                currentString += "B"
        }
    
        if true {
            defer {
                currentString += "C"
            }
            
            defer {
                currentString += "D"
            }
            
            currentString += "E"
        }
    
        currentString += "F"
        
        defer {
            currentString += "G" 
        }
    
        return currentString
    }
    Это будет равно =  A E D C F // эти буквы будут присвоены уже после return. Но при вызове функции мы их не увидимG B

---

## Расширения 

> Расширения (extension) позволяют добавить новую функциональность к уже существующему объектному типу (классу, структуре, перечислению) или протоколу. Таким образом вы можете расширять возможности любых типов, даже тех, что входят в состав Swift, то есть таких типов данных, доступ к исходным кодам которых у вас отсутствует.

Расширения могут добавлять новую функциональность к типу, но не могут изменять существующую. **Суть расширения состоит исключительно в наращивании возможностей, но не в их изменении.**

    extension ИмяРасширяемогоТипа {
        // описание новой функциональности для расширяемого типа
    }

Это дополнительный функционал для класса стурктуру и тд, для типа. 

В расширениях по умолчанию нельзя использовать свойства хранения(сторед прочерти). 

> ПРИМЕЧАНИЕ Расширения могут добавлять только новые вычисляемые свойства. При попытке добавить хранимые свойства или наблюдателей свойств происходит ошибка.

Рассмотрим следующий пример. Ваша программа оперирует расстояниями и использует для этого значения типа Double. 

    extension Double {
        var asKM: Double { return self / 1000.0 }
        var asM: Double { return self }
        var asCM: Double { return self * 100.0 }
        var asMM: Double { return self * 1000.0 }
    }
    
    let length: Double = 25 // 25 метров
    length.asKM // расстояние 25 метров в километрах 0.025
    length.asMM // расстояние 25 метров в миллиметрах — 25000

Для изменения свойств перечислений (enum) и структур (struct) не забывайте использовать модификатор mutating.

    extension Int {
        mutating func squared() {
            self = self * self
        }
    }
    var someInt = 3
    someInt.squared() // 9


По сути расширения нужны для разбивки кода для удобства пользования. 
Когда в отдельный файл нужно засунуть расширения какого то типа, то нужно указать так: ViewController + Extension. То есть есть внеглассное указание, что для таких файлов надо указывать знак Плюс.

Если для стуктуры объявить init в расширении то дефолтный init не пропадет в структуре и будет два init. Если же написать init в структуре то дефолный init пропадет.

> ПРИМЕЧАНИЕ Для классов расширения могут добавлять только новые вспомогательные инициализаторы. Попытка добавить назначенный инициализатор или деинициализатор приведет к ошибке.

Метод объявленный в наследнике не может быть переписанным(override). **Extension + override** не работают по умолчанию.
Есть обходной путь, можно в классе перед методом написать @objc dynamic func test() {} и уже после override func будет работать в расширении.

Вопрос почему нельзя использовать хранимые свойства в расширении. Ответ Расширение не имеет собственного хранилища для хранения состояния свойств.

Расширения позволяют указать реализацию по умолчанию для любого метода этого протокола.

    protocol Descriptional {
        func getDescription() -> String
    }
    // расширение протокола и указание реализации метода по умолчанию
    extension Descriptional {
        func getDescription() -> String {
            return "Описание объектного типа"
        }
    }
    // подпишем класс на протокол
    class myClass: Descriptional {}
    // вызовем метод
    print(myClass().getDescription())
    Консоль
    Описание объектного типа

Несмотря на то что в классе myClass отсутствует реализация метода getDescription(), при его вызове не появляются сообщения об ошибках. Это связано с тем, что протокол имеет реализацию метода по умолчанию, описанную в его расширении.

> ПРИМЕЧАНИЕ Реализация методов по умолчанию для протоколов доступна только при использовании расширений. Вы не можете наполнить метод непосредственно при объявлении протокола.

---

## Протоколы

> Протокол — это перечень требований, которым должен удовлетворять тип данных, соответствующий ему. В более сложных случаях протокол также может содержать не просто требования наличия свойств и методов, но и их конкретную реализацию.

Протокол определяет образец методов и описывает как реализация должна выглядеть. 
Протокол может быть принят классом, структурой или перечислением.
Протокол это набор методов и свойств без реализации. То есть из него нельзя сделать объект как из класса. Протокол это тип как класс структура или enum. 

Класс подписанный на протокол **обязан реализовать** все свойства и метода из протокола.
Что бы использовать протокол **только для класса**, нужно после типа протокола указать **AnyObject** (Раньше это слово было class).

Если использовать расширение протокола Extension SomeProtocole, то в нем можно реализовать все свойства и метода протокола для использования их по умолчанию. И когда класс будет подписан под этот SomeProtocole то ему не надо будте реализовывать все эти свойства протокола. 

Так же существует так называемая ошибка **Diamond problem** которая при множественной реализации через расширения(установка по умолчанию) одного и тоже же метода или свойства, Swift не понимает что ему выдать, и выдает ошибку. Например есть основной протокол ,и от него идет еще два подписанный на него, и вот эти два протокола через расширения устанавливают значения по умолчанию, и если подписать класс на оба этих протокола, то Swift не поймет какой брать, и будет ошибка. Что бы ее избежать надо в классе(или расширении) переписать этот метом или свойство. 

Тоже самое может быть если сделать два одинаковых метода в двух наследниках протокола. Управляем точно так же, прописывает снова руками в классе.

Вам не нужно писать слово mutating при реализации этого метода для класса. Слово mutating используется только структурами или перечислениями.

> Ключевое слово mutating применимо только к структурам. Если метод экземпляра протокола объявляется изменяемым, необходимо использовать ключевое слово mutating со структурами, соответствующими протоколу. Классы тоже могут включать протоколы, но использовать ключевое слово mutating с ними не обязательно.

Синтаксис наследования протокола аналогичен синтаксису наследования класса, но с возможностью наследовать сразу несколько протоколов, которые разделяются между собой запятыми.

Композиции протоколов это тип, который будет соответствовать сразу нескольким протоколам. можете перечислить столько протоколов, сколько нужно, разделяя их между собой знаком амперсанда (&).  

      func wishHappyBirthday(to celebrator: Named & Aged)
      
Опциональные требования для протокола. Протоколы с маркировкой @objc могут приниматься только классами, но не структурами или перечислениями. Опциональное требование протокола может быть вызвано при помощи опциональной цепочки. должны иметь префиксный модификатор optional и @objc

    @objc protocol CounterDataSource {
        @objc optional func increment(forCount count: Int) -> Int
        @objc optional var fixedIncrement: Int { get }
    }

Если класс не просто принимает протоколы, но и наследует другой класс, то имя родительского класса необходимо указать первым, а за ним через запятую — список протоколов:

    class ИмяПринимающегоКласса: ИмяСуперКласса, ИмяПротокола, ИмяДругогоПротокола {
    // тело класса
    }

**Требуемые методы**

Помимо свойств, протокол может содержать требования к реализации одного или нескольких методов. Для требования реализации метода типа необходимо использовать модификатор static, а для изменяющего метода — mutating.

> ПРИМЕЧАНИЕ Если вы указали ключевое слово **mutating** перед требованием метода, то указывать его при реализации метода **в классе уже не нужно**. Данное ключевое слово требуется **только** при реализации **структуры**.

    protocol RandomNumberGenerator {
        var randomCollection: [Int] { get set }
        func getRandomNumber() -> Int
        mutating func setNewRandomCollection(newValue: [Int])
    }

**Требуемые инициализаторы**

Протокол может предъявлять требования к реализации инициализаторов. При этом в классах можно реализовать назначенные (designated) или вспомогательные (convenience) инициализаторы. В любом случае перед объявлением инициализатора в классе необходимо указывать модификатор required. Это гарантирует, что вы реализуете указанный инициализатор во всех подклассах данного класса.

> ПРИМЕЧАНИЕ Нет нужды обозначать реализацию инициализаторов протокола модификатором required в классах, которые имеют модификатор final.

    protocol Named {
        init(name: String)
    }
    
    class Person: Named {
        var name: String
        required init(name: String) {
            self.name = name
        }    
    }


---

## Дженерики
Универсальный код позволяет вам писать гибкие, общего назначения функции и типы, которые могут работать с любыми другими типами.

Универсальный тип, используется в коллекциях(массив, словари, сет) а так же в опциональных типах.

Использование в функциях, структурах или классах, протоколах:
* Протокол дженерик В протоколах нельзя писать <T>. Его можно сделать дженерик только с использованием ключевого слова associatedType T.
* При подписании класса или структуры на дженерик протокол, внутри указывается typealiace T = Int. Если же класс или структура уже дженерик, то это уже можно не писать.

По сути дженерик нужен только для того, что бы переиспользовать код(DRY).

 **Минусы дженерики увеличивают время компиляции и размер приложения, сложный дебагинг.**

Реализуем универсальную функцию, меняющую значения входных параметров произвольных типов данных.

    func change<T>(a: inout T, b: inout T) {
        let temporaryA = a
        a = b
        b = temporaryA
    }

В универсальной функции change<T>(a:b:) параметр типа T в списке аргументов заменяет указание на конкретный тип. Но при этом указано, что и a и b должны иметь один и тот же тип данных T.

> ПРИМЕЧАНИЕ Обратите внимание, что при вызове универсальной функции заполнитель типа опускается. Он используется только на этапе объявления дженерика.

Заполнитель типа может состоять не из одного, а из нескольких параметров. Показан пример универсальной функции printValues<T1,T2>(a:b:) с параметрами типа T1 и T2, которые используются для указания типа данных аргументов. Таким образом, вы можете передать в функцию как значения различных типов (например, String и Double, Int и UInt), так и одного и того же типа.

    func printValues<T1,T2>(a: T1, b: T2) {
        print("Значение 1 \(a), значение 2 \(b)")
    }
    printValues(a: "book", b: 15)
    printValues(a: 4, b: 5)

Параметры типа могут быть использованы не только для аргументов, но и для возвращаемого значения. 

    func getSelf<T>(_ a: T) -> T {
        return a
    }
    getSelf(15) // 15

**Ограничения типа**
На первый взгляд такая функция выглядит вполне рабочей, но при компиляции вы получите сообщение об ошибке (рис. 34.1). Дело в том, что оператор + может быть использован только при сложении значений конкретных типов данных (они перечислены в тексте ошибки). Так, например, вы вполне можете сложить два значения типа Int, но для типа String эта возможность недоступна. Получается, что необходимо ввести ограничения, или, другими словами, указать,
какие именно типы данных могут быть использованы вместо параметра T, таким образом исключив String (и другие неподходящие типы).

    func sum<T>(_ a: T, _ b: T) -> T {
        return a + b
    }
Ограничения типа могут быть указаны двумя способами:

* Непосредственно в заполнителе типа, через двоеточие после параметра(Numeric).


      func sum<T: Numeric>(_ a: T, _ b: T) -> T {
        return a + b
      }

* С помощью ключевого слова where, указываемого после сигнатуры функции.


      func sum<T>(_ a: T, _ b: T) -> T where T: Numeric {
          return a + b
      }

**Универсальные объектные типы**
Помимо универсальных функций, к дженерикам относятся и универсальные объектные типы. Для реализации стека воспользуемся структурой, реализовав в ней свойство items, которое будет хранить элементы стека, а также два метода:

    struct Stack<T> {
        var items = [T]()
        mutating func push(_ item: T) {
            items.insert(contentsOf: [item], at: 0)
        }
        mutating func pop() -> T {
            return items.removeFirst()
        }
    }
    
    var genericIntStorage = Stack(items: [1,2,3,4,5])
    var genericStringStorage = Stack(items: ["Bob", "John", "Alex"])

Для создания универсального типа вновь используется заполнитель <T>, который указывается после имени объектного типа. Параметр типа T обеспечивает использование любого типа данных для значений стека.
**Ограничения** доступны и при работе с универсальными типами.

    struct Stack<T: Numeric> {
        var items = [T]()
        mutating func push(_ item: T) {
            items.insert(contentsOf: [item], at: 0)
        }
        mutating func pop() -> T {
            return items.removeFirst()
        }
    }




---

## ARC

> Каким образом Swift принимает решение о том, что экземпляры классов могут быть удалены? Для этого специальный механизм ARC ведет подсчет ссылок на каждый объект в куче, и в случае, если их количество равняется нулю, объект удаляется из памяти. Automatic Reference Counting (ARC) — это специальный механизм автоматического подсчета ссылок. Именно он подсчитывал количество входящих сильных ссылок на каждый объект и при возможности удалял неиспользуемые экземпляры.

**ARC**  для отслеживания и управления памятью вашего приложения
**weak и unowned** weak опциональный. Еще unowned быстрее, производительность.
weak let  pidr: Contact? 'weak' must be a mutable variable, because it may change at runtime то есть он должен быть переменной, что бы вернуть nil потому как он опциональный… никаких let вместе с weak

Он работает только с референс типами(ссылочный типы). Классы, кложеры и акторы.
ARC автоматический считает strong ссылки делая +1 каждый раз при strong ссылки. Weak unowned не считают ссылки, то есть нет +1. 

Объект считается мертвым когда количество ссылок на него будет равно 0.

Глобальные переменные хранятся в GVAR, то есть в памяти глобальных переменных, не в СТЕК и не в КУЧЕ.

Есть менеджеры памяти это strong weak unowned ссылки. 

**По умолчанию создается strong ссылка.** Пока есть strong ссылка, этот объект будет существовать в куче.

**Weak и Unowned ссылки не удерживают объект в памяти.** 
Они нужны, что бы разорвать рефери цикл(утечку памяти). 

Разница в том, что при освобождение из памяти Weak становиться nil. А unowned продолжает хранить ссылку (будет крэш приложения).

Утечка памяти происходит потому, что объекты ссылаются друг на друга, тем самым создавая еще больше strong ссылки. Тем самым уже не по одной strong ссылке есть, а по две и deinit и даже nil не поможет. 
Будет утечка памяти до тех пор пока вся память не кончиться и приложение закроется. 
Что бы остановить это, нужно указать внутри класса weak перед свойством, что держит другой класс. weak var person: Person? = Person. 

Если в кложуре много будет self, и произойдет то, что мы вышли из этого места выполнения кода, а он продолжился… для этого надо использовать strong ссылку.

    guard self = self else { return }
    
В отличии от слабых ссылок, бесхозные(unowned) ссылки всегда имеют значение. Из-за этого бесхозные ссылки имеют неопциональный тип. 

$${\color{blue}Ссылки \space в \space замыканиях}$$ 
 
А может ли value type передаваться по ссылке?

    var a = 2
    
    let f = { 
        print(a)
    }
    
    f()
    
    a = 3
    
    f()
    
    Консоль
        2
        3

Это и есть пример того, как значимый тип(value type) данных может быть передан по ссылке. Запомните, что **замыкания всегда захватывают значения по ссылке**, а не копированием! Даже значение value type!


---

## Тип памяти
Есть две области в оперативной памяти: 
* Стек
* Куча

Стек работает по принципу **LIFO** последний пришел первый вышел.

Указатели или ссылки класса лежат в стеке, а сам класс лежит в куче.

Бывают три типы памяти:
* Статическая память в которой размещается код приложения, различные библиотеки, метаданные и глобальные переменные, необходимые для работы.
* Динамическая для кучи. Используется для динамического выделения памяти, в которой память выделяется динамически по запросу.
* Автоматическая для использования стека. Автоматическая память, в которой хранятся все локальные для текущей области видимости параметры.

Стек создается во время компиляции, куча инициализируются  во время запуска приложения 

$${\color{blue}Статическая \space память}$$ 
 
В процессе компиляции ваше приложение переводится в машинный код, то есть код, понятный компьютеру. А в процессе загрузки этот код, вместе с различными библиотеками, загружается в статическую область памяти, откуда по мере необходимости вызывается. Статическая память выделяется один раз еще до появления приложения на экране и существует все время, пока приложение работает.

$${\color{blue}Автоматическая \space память}$$ 
Автоматическая память работает на основе структуры данных стек (stack), то есть по принципу последним пришел — первым вышел (Last in, first out, или LIFO). Объекты, записанные в стек, похожи на стопку тарелок: последняя поставленная тарелка не дает убрать те, что находятся ниже, пока данная тарелка сама не будетубрана. В стеке хранятся все локальные (относящиеся к данной области видимости) значения. То есть как только создается новая переменная, она помещается в стек, следующая переменная помещается поверх нее, и т. д. А при выходе из данной области видимости все созданные значения последовательно удаляются из стека.

$${\color{blue}Динамическая \space память}$$ 
Динамическая память — это область, память в которой выделяется по запросу приложения. Данная область также называется кучей (heap). Объекты в куче не упорядочены, программа при необходимости захватывает память требуемого объема и помещает туда значение. При этом в стеке создается запись, в которой сохраняется ссылка на объект в куче.

**Стандартный цикл жизни экземпляров объектных типов состоит из следующих шагов:**
* выделение памяти (в стеке или в куче);
* инициализация (выполнение кода в методе init);
* использование;
* деинициализация (выполнение кода в методе deinit, актуально только для классов);
* освобождение памяти.


---

## Делегирование
Делегирование – это шаблон проектирования, который позволяет классу передавать или делегировать некоторые из своих обязанностей другому классу.
Представьте, что вы и я – часть команды, которая доставляет шоколадное печенье на мероприятие. Ваши обязанности заключаются в выпечке печенья, и вы делегируете на меня изготовление теста для печенье. Когда я закончу, я отдам вам тесто для печенья, чтобы вы могли его испечь.
Делегирование – один из самых распространенных шаблонов проектирования в iOS. Практически невозможно создать приложение для iOS без использования делегирования.

Для этого нужно: 
* Протокол Класса. 
* Свойство в первом объекте вид делегат. 
* Второй объект должен подписаться и стать делегатом.

---

## Тайпкастинг 
**Any** нужен для использования когда не знаешь кокой конкретно тип будет в массиве. В any можно засунуть все что относиться к типу значения. 

Благодаря псевдониму Any можно создавать хранилища неопределенного типа данных. Объявим массив, который может содержать элементы произвольных типов. Массив things содержит значения типов: Int, Double, String, (Double, Double) и даже значение функционального типа(String)->String. Таким образом, передвами целый набор различных типов данных.
При запросе любого из элементов массива вы получите значение не того типа данных, который предполагался при установке конкретного значения, а **типа Any**.

> ПРИМЕЧАНИЕ Псевдоним Any несовместим с протоколом Hashable, поэтому использованиетипа Any там, где необходимо сопоставление, невозможно. Это относится, например, к ключам словарей.

К **AnyObject** можно засунуть только ссылочный тип, такие как классы и кложеры. Класс можно и в Any засунуть но…

* is это проверка типа, работает в пару с Any.
* as это уже приведение типов одного к другому. **Upcasting**.
  
Так же есть **Downcasting** который использует as?! 
Опцианальный **as** работает во время компиляции, в то время как **as?** работает в runtime, то есть когда работает приложение. От этого может страдать производительность(от as?).

Понижающее приведение:
* Опциональная форма (as?)
* принудительная форма (as!)

---

## Контроль доступа
Это структурирование и защита кода от внешних воздействий.
Есть несколько доступов:
* Open
* Public
* Internal 
* Fileprivate
* Private

Open и public нужны для доступа к классам.

Fileprivate и private закрывают доступ. Fileprivate доступен только в файле. Private не доступен.

По умолчанию все находится в internal. 

Если в классе написать доступ private то и все свойства и методы тоже будут приватными. Что бы получить доступ к приватному классу, надо так же указать private для экземпляра класса. 
Для тестов нужно прописывать **@testable**

Подкласс не может быть уровнем доступа выше чем его супер класс: вы не можете написать подклассу public, если его суперкласс имеет internal доступ.

$${\color{blue}open \space открытый}$$ 

Наименее ограничивающий уровень доступа. Позволяет использовать элемент(объектный тип, свойство или метод) без каких-либо ограничений. Данный модификатор применяется исключительно к классам и их элементам.

$${\color{blue}public \space публичный}$$ 

Подобно open, данный модификатор позволяет использовать элемент без ограничений. Однако в случае с классами есть некоторые особенности:
* класс, имеющий уровень доступа public (или более строгий), может иметь подклассы только в том модуле, где был объявлен;
* элементы класса, имеющие уровень доступа public (или более строгий),могут быть переопределены (с помощью оператора override) в подклассе только в том модуле, где объявлен сам класс. Для структур данный модификатор является наивысшим (наименее ограничивающим), так как структуры не поддерживают наследование, а соответственно, и модификатор open.

$${\color{blue}internal \space внутренний}$$ 

Данный модификатор используется в случаях, когда необходимо ограничить использование объекта модулем. Таким образом, объект будет доступен во всех исходных файлах модуля, исключая его использование за пределами модуля.

$${\color{blue}ileprivate \space приватный \space в \space пределах \space файла}$$ 

Данный модификатор позволяет использовать объект только в пределах данного исходного файла.

$${\color{blue}private \space приватный}$$

Данный модификатор позволяет использовать объект только в пределах конструкции, в которой он объявлен. Например, объявленное в классе свойство или метод не будут доступны извне или в его расширениях.

По умолчанию все объекты имеют уровень доступа internal. Для того чтобы изменить его, необходимо явно указать требуемый уровень.


---

## Singleton 
При объявлении класса синглтоном ты не можешь создать много экземпляров этого класса, так как он один работает теперь на всем проекте.

**Singleton** это паттерн проектирования в программировании, который позволяет создать класс таким образом, чтобы у него был только один единственный экземпляр во всем приложении. 
Это полезно, когда у вас есть компонент, который должен существовать в единственном экземпляре, чтобы обеспечить глобальный доступ к его функциональности.

Пример: 
* UIApplication
* UserDefault

Нарушает принцип единственной ответственности класса.

---

## Менеджеры зависимостей
Это менеджер по управления и подключению разных библиотек к твоему проекту. 

* SPM
* CocoaPods

SPM проще. 
CocoaPods сложнее и при это после установки нужно использовать **белый файл проекта**, а не синий. Все зависимости нужно писать в отдельный файл и делать pod init, pod instal.

---

## Жизненный цикл приложения
Приложение посылает сообщения классу **appDelegate**, в котором можно эти сообщения поймать и обработать, так же происходит посыл сообщения NSNotificationCenter с соответствующим содержанием для каждого из состояний приложения.

Сначала приложение не запущенно. Потом пользователь **запускает приложение**. Оно переходит в состояние **Foreground**, в котором приложение становится сначала **Inactive** —  на этом этапе выполняется код программы, но не обрабатываются события интерфейса пользователя (интерфейс не отображается, касания не обрабатываются и.т.п.). Затем переходит в этап **Active**, в котором выполняется код и обрабатываются все события UI. 

Если пользователь запустит другое приложение, то текущее приложение перейдет в состояние Inactive и затем в состояние **Background**(в этом состоянии коды выполняется ограниченное время, и не обрабатываются события UI). Нужно понимать, что именно в этом состоянии можно заставить приложения получить, допустим, из интернета самые свежие обновления чего либо, и дать их приложению, что бы когда пользователь вернул приложение в Foreground он мог увидеть эту информацию. 
Так же нужно понимать, что при включенном режиме энергосбережения могут эти процессы в background и не выполнится…

После весьма короткого состояния Background приложение переходит в состояние **Suspended**. В этом состоянии код не выполняется вовсе и система может убить приложение для освобождения памяти, если оно потребуется.

Цикл:
* Запуск приложения
* Foreground
* Inactive
* Active
* Background
* Inactive
* Suspended


Список делегатов:
* sceneWill Resigh Active собирается стать неактивным
* sceneDid Enter Background стало нёактивным
* sceneWill Enter Foreground собирается вернуться на передний план
* sceneDid Become Active стало активным
* sceneDidDisconnect

  
Вопросы на собесе:

Какие этапы проходит приложение, перед тем как появиться на экране, после перегрузки устройства?
    * Перезагрузка устройства = Переводит приложение в состояние не запущено, даже если оно продолжает находиться в диспетчере приложений.
    * Когда пользователь запускает приложение в первый раз или после перезагрузки система переходит через следующие стадии:
    * не запущено -> не активно -> активно

Как приложение реагирует на прерывания, такие как СМС сообщения, входящий звонок, календарь и т.д. ?
* Приложение временно переходит в неактивное состояние и остается в нем до тех пор, пока пользователь не решит, принять или проигнорировать прерывание; App in foreground
* Если пользователь игнорирует прерывание, приложение снова активируется; Incoming call or sms or calendar notification
* Если пользователь принимает прерывание, приложение переходит в состояние приостановки.

Существует множество причин, по которым приложение может быть запущено: нажатие на иконку на домашнем экране, поступление push-уведомления, перехват ссылки, меню быстрых действий и др. В одних случаях будет загружен и отображен графический интерфейс, а в других вся работа будет выполняться в фоновом режиме. 

---

## Жизненный цикл ViewController

    * init
    * loadView
    * viewDidLoad
    * viewWillAppear
    * viewWillLayoutSubviews 
    * viewDidLayoutSubviews
    * viewDidAppear
    * viewWillDisappear
    * viewDidDisappear
    * deinit
    
 Еще есть didReciveMemoryWarning для того что бы можно было отследить утечку памяти или вся память заполнена.
 И viewWillTransitionToSize если нужно самостоятельно обработать анимацию при повороте, то можно его. 

    * init установка свойств vc;
    * loadView подмена стандартной view на кастомную;
    * viewDidLoad view нашего ис создано, используется для заполнения UI;
    * viewWillAppear vc начинает начинает появлять на экране, используется для обновления UI данными, которые могли измениться, пока ус не отображался на экране;
    * viewWilLayoutSubviews вызывается перед тем как view нашего vc, разместит свои subviews. Границы окончательно подсчитаны.
    * view DidLayoutSubviews уведомляет, что view нашего ус только что разместила свои subviews;
    * viewDidAppear вызывается как только ис появился на экране;
    * viewWillDisappear vc начинает удаляться с экрана;
    * viewDidDisappear vc удален с экрана;
    * deinit деинициализация vc, удаление из памяти устройства;
    
SwiftMagic

Итак, основная разница заключается в том, что loadView отвечает за создание и инициализацию представления контроллера, в то время как viewDidLoad предназначен для настройки и инициализации данных уже существующего представления.

---

## Императивный Декларативный
Императивный подход основывается на определении последовательности команд и операций, которые выполняются шаг за шагом в определённом порядке. Разработчику необходимо подробно описать, как программа должна работать и какие операции должны быть выполнены, чтобы добиться нужных результатов.
Декларативный подход, в свою очередь, сфокусирован на том, чтобы описывать, что программа должна делать, а не как это должно быть выполнено. Разработчик описывает желаемый результат, а система сама определяет, как его получить.

--

## GCD задачи

Если в задаче стоит DispatchQueue.main.async то он будет выполняться после того как выполниться функция. То есть  async отложит выполнение на потом. 

    func firstMethod() {
        print ("A" )
    
        DispatchQueue.main. async {
            print ("B" )
            }
    
        print("C" )
    }
    firstMethod () // A C B

Если там будет стоять sync просто, то будте runtime ошибка, потому как синк будут запушен для выполнения не дождавшись окончания функции из главного потока. И функция так же незавершится, так как ждет пока sync закончит выполнение задачи. Короче мешают друг другу. При такой записи не будет ошибки: Dispatchadieue.global().sync, он выполнит код в бекграунде, не в основном потоке main.

___

## User Defaults
User Defaults обеспечивает долговременное хранение дат, числовых, логических, строковых и других типов данных. Удаление приложения из устройства приводит к уничтожению всех данных в User Defaults. 

Основное предназначение User Defaults – хранение различных параметров пользователя (имя, почтовый адрес, возраст, пол), настроек приложения (выбранный язык, валюта, цветовая схема) и различные флаги, содержащие логические значения (была ли показана инструкция при входе, были ли синхронизированы данные с сервером). 

User Defaults хранит данные в plist-файлах. Работает на основе паттерна **Одиночка (Singleton)**. 

---

## Size Class
Нужно для того что бы использовать приложение в разных положениях. В горизонтальном и в вертикальном. (Compact and regular). В большинстве случаев, для адаптации к изменению ориентации экрана более подходит **viewWillTransition(to:with:)**, так как он предоставляет конкретную информацию о новом размере экрана и длительности анимации перехода.

Какой использовать и когда:
* Используйте viewWillTransition(to:with:), когда вам нужно выполнить действия, специфичные для изменения ориентации экрана. Например, вы можете перестроить интерфейс, пересчитать размеры элементов или изменить расположение ваших представлений.
* Используйте traitCollectionDidChange(_:), когда вам нужно реагировать на изменение trait collection в более общем контексте, который может включать в себя не только изменение ориентации, но и другие факторы, влияющие на пользовательский интерфейс.

        override func traitCollectionDidChange(_ previousTraitCollection: UITraitCollection?) {
            if view.traitCollection.horizontalSizeClass == .compact {
            
            }
            
            if view.traitCollection.verticalSizeClass == .regular {
            
            }
        }

---

## Frame Bounds
Размеры графического элемента в родительской системе координат называются **frame**, а в собственной системе координат – **bounds**. 

Вот ответ на заданный выше вопрос: 
Свойство frame определяет, где находится представление в системе координат супервью. Свойство bounds определяет внутренние размеры и положение представления относительно собственной системы координат. 

* frame это прямоугольник, который определяет положение и размер вьюхи в системе координат супервью. Он задается четырьмя значениями: x, y, width и height.
* bounds это прямоугольник, определяющий размер и координаты внутри вьюхи в её собственной системе координат. По умолчанию начало координат этой системы находится в верхнем левом углу вьюхи.

---

## UIResponder 
Для обработки событий, возникающих в процессе жизненного цикла приложения, служат разнообразные механизмы. Так, например, для работы с касаниями используется класс **UIResponder**, для обработки push-уведомлений – **Notification Center**, для запуска таймера – класс **Timer** и т.д. 

Класс UIResponder содержит в себе функциональность для реагирования не только на события касания, но и на нажатия физических клавиш, движения устройства (например, встряхивание) и команды от внешних аксессуаров (например гарнитуры). 
Это становится возможным благодаря переопределению в дочернем классе (который должен обрабатывать события) специальных методов. 

К примеру, для обработки касаний используются следующие четыре метода: 
* touchesBegan(_:with:) – палец коснулся экрана; 
* touchesMoved(_:with:) – палец движется по экрану; 
* touchesEnded(_:with:) – палец прекратил касание; 
* touchesCancelled(_:with:) – касание отменено.

  
Для обработки нажатий физических клавиш используются методы **pressesBegan**, **pressesChanged**, **pressesEnded**, **pressesCancelled**, для движений – **motionBegan**, **motionEnded** и **motionCancelled**, а для внешних устройств – метод **remoteControl Received**.

---
 
## Responder Chain
Это список вероятных ответчиков, т.е. список объектов, которые потенциально могут обработать возникшее событие. Если очередной элемент списка (цепочки) не может обработать событие, оно передается следующему в списке элементу. 

Responder Chain – это реализация шаблона разработки Цепочка обязанностей. Его суть состоит в том, что элементы поочередно опрашиваются на предмет возможности обработки поступивших данных. Если один элемент не смог обработать его, данные о событии передаются следующему элементу в цепочке и т.д. Тот элемент, по которому происходит касание, назначается первым ответчиком (first responder). Если он может обработать событие, он делает это, если нет – передает управление следующему элементу цепочки, и цикл вновь повторяется до тех пор, пока не будет найден элемент, способный обработать событие. Все элементы цепочки ответчиков являются наследниками класса UIResponder. 

Но изначально на сцене нет никакого первого ответчика. В случае события Касание он определяется следующим образом: 

* UIKit создает объект типа UIEvent, подробно описывающий событие; 
* данный объект отправляется в UIApplication и, далее, в UIWindow; 
* UIWindow проводит так называемое hit-тестирование, т.е. с помощью поэтапного вызова метода hitTest(_:with:) для каждого вложенного представления, определяет, с каким именно графическим элементом взаимодействует пользователь; 
* как только данный элемент найден, он назначается первым ответчиком, и начиная от него стартует обход Responder Chain.
  
Для всех остальных типов событий (нажатия физических кнопок, движения гарнитуры и команд от внешних устройств) никакого hit-тестирования не проводится. Данные передаются сразу в элемент, который в текущий момент является первым ответчиком (если он был определен ранее). 
Вы можете влиять на то, какой элемент должен быть первым ответчиком в данный момент с помощью вызова метода becomeFirstResponder() 

___

## UIView
по умолчанию для экземпляра UIView отключена поддержка мультитач (одновременное касание несколькими пальцами). 
Для включения поддержки мультитач конкретному вью необходимо установить значение true в свойстве isMultipleTouchEnabled. 

---

## Auto Layout
Auto Layout — это технология, основанная на понятиях ограничения (constraint) интерфейса. Она динамически вычисляет размер и положение всех графических объектов в иерархии UIView, основываясь на ограничениях, указанных для этих объектов. Если размеры экрана отличаются, то Auto Layout автоматически расположит графический объект на нужное место. Такой подход к проектированию позволяет создавать гибкий (flexible) интерфейс, который может динамически реагировать на внутренние и внешние изменения (например, изменяется ориентация экрана, изменяется размер одного из объектов и т.д.).

---

## Auto Layout и Constraint Resistance
Для некоторых UIView мы не всегда можем применить конкретные значения. Например, если у нас есть UIButton с жестко заданным значением, при локализации текст может быть обрезан.
Чтобы справиться с этим, не требуя изменения приоритета, мы можем использовать другой набор функций, чтобы избежать такого поведения. Двумя из них являются Content Hugging и Content Resistance.
    * Content hugging priority приоритет сопротивления превышения intrinsic content size (не хочу чтобы была больше)
    * Content compression resistance priority приоритет сопротивления занижения intrinsic content size (не хочу чтобы была меньше)

---
 
## Антипаттерн
* Лодочный якорь (Boat anchor) паттерн YAGNI
Этот анти-паттерн означает сохранение неиспользуемых частей системы, которые остались после оптимизации или рефакторинга. Часто, после рефакторинга когда, который является результатом анти-паттерна, некоторые части кода остаются в системе, хотя они уже больше не используются. Так же некоторые части кода могут быть оставлены на будущее, авось придётся ещё их использовать.

* Спагетти-код (Spaghetti code) паттерн Единой ответсвенности. 
Спагетти-код — слабо структурированная и плохо спроектированная система, запутанная и очень сложная для понимания.
Причинами являются — разработка по принципу Да ну, оно же работает! Целых пять тысяч строк!, малоэффективные code review, 

* Solid Одиночка — это порождающий паттерн проектирования, который гарантирует, что у класса есть только один экземпляр, и предоставляет к нему глобальную точку доступа.
Нарушает принцип единственной ответственности класса.

---

## Side tables 
Вкратце, Side Table — механизм, с помощью которого реализуются слабые ссылки. Не каждый объект содержит слабые ссылки, следовательно, и боковые таблицы, иначе это было бы расточительно. Вместо того чтобы напрямую указывать на объект, слабая ссылка указывает на боковую таблицу, которая, в свою очередь указывает на объект. Такое поведение решает две проблемы: Экономия памяти, поскольку память объекта освобождается. Наличие безопасного обнуления слабой ссылки. 

### Side tables — это механизм для реализации слабых ссылок Swift.
Обычно объекты не имеют слабых ссылок, поэтому резервировать место для подсчета слабых ссылок в каждом объекте нецелесообразно. Эта информация хранится извне в дополнительных таблицах, поэтому ее можно выделить только тогда, когда это действительно необходимо.
Как только мы начинаем ссылаться на объект слабо (weak reference), то создается боковая таблица, и теперь объект вместо сильного счетчика ссылок хранит ссылку на боковую таблицу. Сама боковая таблица также имеет ссылку на объект.
### Side Table — это просто счетчик ссылок + указатель на объект.

Механизм "side tables" в Swift используется для отслеживания слабых ссылок и управления памятью для них. Он связан с реализацией подсчета ссылок (reference counting) в Swift.
Когда вы создаете слабую ссылку на объект, Swift использует "side table" для хранения дополнительной информации о ссылке, такой как информация о циклических зависимостях. Это позволяет Swift отслеживать, когда объект, на который вы создали слабую ссылку, был деинициализирован, и автоматически обнулять эту ссылку.


---

## GCD
GCD поддерживается как в iOS, так и в macOS, watchOS и tvOS.

Очередь работает по принципу **FIFO**, таким образом первая задача на очереди будет первой направлена на выполнение на потоке.

Мультипоточность в программировании позволяет выполнять несколько задач (или потоков) одновременно, что может значительно повысить производительность приложений. В Swift и других языках программирования существует несколько способов реализации мультипоточности, и одним из самых распространенных инструментов для управления потоками в Swift является **GCD**.

> GCD (Grand Central Dispatch) это технология в Swift и Objective-C, предназначенная для управления параллельными задачами. Она обеспечивает простой способ создания и управления потоками. Основная идея GCD заключается в том, что вы можете определить задачи (или блоки кода) и отправить их в определенные очереди выполнения. GCD автоматически управляет выполнением этих задач на доступных ядрах процессора, что делает мультипоточное программирование более удобным и эффективным.

В **GCD** существуют два основных типа очередей:
* Очереди серий **(Serial Queues)**: Задачи в таких очередях выполняются последовательно, одна за другой, и в одном потоке, в порядке их добавления в очередь. Это полезно, когда важна последовательность выполнения задач.
* Очереди конкурентности **(Concurrent Queues)**: Задачи в таких очередях выполняются параллельно, в нескольких потоках, но порядок их выполнения не определен. Это позволяет использовать все доступные ядра процессора для более быстрого выполнения задач.Процесс переключения между потоками является одним из самых ресурсозатратных в многопоточной среде, а имя ему context switch.


В GCD (Grand Central Dispatch), main, global и custom представляют собой разные очереди выполнения (dispatch queues), которые используются для управления параллельными задачами. 

Давайте разберемся с каждым типом:
* Главная очередь **(main)**: Это специальная очередь, предназначенная для выполнения задач на главном потоке вашего приложения. Все пользовательский интерфейс (UI) обновления и взаимодействия с элементами пользовательского интерфейса должны выполняться на главной очереди. Попытка выполнить задачи, изменяющие интерфейс, на других очередях может привести к проблемам и нестабильной работе приложения. **Это serial очередь**.
  
* Глобальные очереди **(global)**: Глобальные очереди предоставляют доступ к готовым к использованию потокам в GCD. Они делятся на несколько уровней приоритета, обозначенных как "quality of service" (QoS). Например, есть очереди с приоритетами .userInteractive, .userInitiated, .default, .utility и .background. Вы можете выбрать подходящий уровень приоритета в зависимости от того, насколько быстро вы хотите, чтобы задача была выполнена и как она влияет на производительность системы. **Это conrurrent очереди**.
  
* Пользовательские **(custom)** очереди: Пользовательские очереди это очереди, которые вы можете создать самостоятельно для выполнения задач с определенными требованиями или приоритетами. Вы можете создавать пользовательские очереди с различными приоритетами и настраивать их в соответствии с вашими потребностями. 

Quality of Service:
Эти значки, такие как .userInteractive, .userInitiated, .default, unspecified, .utility и .background, представляют разные уровни "качества обслуживания" (Quality of Service, QoS) в Grand Central Dispatch (GCD). Они используются для управления приоритетами выполнения задач в глобальных очередях в зависимости от их важности и воздействия на производительность.

* .userInteractive: Этот уровень QoS предназначен для задач, которые взаимодействуют с пользователем и требуют максимальной отзывчивости. Это могут быть анимации пользовательского интерфейса, реакция на жесты и другие действия пользователя. Задачи с этим уровнем приоритета выполняются немедленно и максимально быстро.
  
* .userInitiated: Этот уровень подходит для задач, инициированных пользователем, которые необходимо выполнить с высоким приоритетом. Это могут быть загрузки данных по запросу пользователя или другие операции, которые пользователь ждет. Задачи с этим уровнем приоритета выполняются быстро, но не столь критичны для отзывчивости, как .userInteractive.
  
* .default: Этот уровень QoS является стандартным уровнем и используется для большинства общих задач. Это может включать в себя обработку данных, вычисления и другие операции, которые не имеют высокой степени влияния на производительность или отзывчивость приложения. Задачи с этим уровнем приоритета выполняются в среднем темпе.
  
* .utility: Этот уровень предназначен для задач, которые могут выполняться длительное время и не требуют максимальной отзывчивости. Это могут быть фоновые операции, такие как индексация данных или регулярные обновления. Задачи с этим уровнем приоритета выполняются медленнее, чтобы не конкурировать с более важными задачами.
  
* .background: Этот уровень предназначен для фоновых задач, которые выполняются без непосредственного воздействия пользователя и не критичны с точки зрения производительности. Это могут быть отправка данных для аналитики, синхронизация данных с сервером, загрузка контента в фоновом режиме и другие асинхронные операции. Задачи с этим уровнем приоритета выполняются очень медленно и имеют самый низкий приоритет.
  
* .unspecified GCD определяет приоритет задачи на основе контекста, в котором она выполняется, или на основе настроек по умолчанию для данного типа задачи.


### DispatchWorkItem
Это класс, являющийся абстракцией над выполняемой задачей, который предоставляет нам ряд полезных методов. Например метод notify, позволяющий уведомить какую-либо очередь о выполнении задачи и следом выполнить какую-либо работу на уведомленной очереди. DispatchWorkItem позволяет нам более явно задать логику, без использования вложенных друг в друга замыканий и хаотичных вызовов методов async / sync. 

Помимо notify, DispatchWorkItem дает нам возможность отменять задачу с помощью метода cancel. Важно понимать, что задачу можно отменить только в том случае, если она на момент отмены ожидает в очереди. Если поток уже начал выполнять задачу, она не будет отменена. Метод notify вызовется даже при отмененной задаче.

### Semaphore
Это базовый инструмент синхронизации в GCD. Semaphore позволяет нам ограничить количество потоков, которые могут единовременно обращаться к очереди. Для этого необходимо передать количество потоков в инициализатор класса DispatchSemaphore. Помимо ограничения количества потоков, семафор позволяет блокировать очередь до тех пор, пока не будет вызван метод signal. 
Есть инкримент и дикримент wait() signal()

### DispatchGroup
Это объект, позволяющий объедinitь задачи в группу и синхронизировать их поведение. Группа позволяет присоедinitь к ней несколько задачь или DispatchWorkItem и запланировать их асинхронное выполнение на одной или нескольких очередях. Когда все задачи в группе будут выполнены, группа уведомит об этом какую-либо очередь и выполнит на ней completion handler. Так же группа позволяет нам дождаться выполнения задач в группе синхронно, без использования уведомления. Есть инкримент и дикримент Enter() Leave()

### Dispatch barrier
Это механизм синхронизации задач в очереди. Когда мы добавляем барьер в параллельную очередь, она откладывает выполнение задачи, помеченной барьером (и все остальные, которые поступят в очередь во время выполнения такой задачи), до тех пор, пока все предыдущие задачи не будут выполнены. После того, как все предудщие задачи будут выполнены, очередь выполнит задачу, помеченную барьером самостоятельно. Как только задача с барьером будет выполнена, очередь вернется к своему нормальному режиму работы.

### asyncAfter – метод, позволяющий отложить асинхронное выполнение задачи на определенное время.

**Проблемы** 
* Deadlock — ситуация, в которой поток бесконечно ожидает доступ к ресурсу, который никогда не будет освобожден
* Race condition — ситуация, в которой ожидаемый порядок выполнения операций становится непредсказуемым, в результате чего страдает закладываемая логика    

---

## Mutex
**Mutex** — примитив синхронизации, позволяющий захватить ресурс. Подразумевается, что как только поток обратиться к ресурсу, захваченному мьютексом, никакой другой поток не сможет с ним взаимодействовать до тех пор, пока текущий поток не освободит этот ресурс.
Стоит отметить, что mutex работает по принципу FIFO, то есть потоки будут захватывать ресурс по освобождению в том порядке, в котором данные потоки обратились к ресурсу. NSLock более удобная реализация базового mutex из фреймворка Foundation
Reqursive mutex — разновидность базового mutex, которая позволяет потоку захватывать ресурс множество раз до тех пор, пока он не освободит его.
Condition еще один примитив синхронизации. Задача, закрытая condition, не начнет свое выполнение до тех пор, пока не получит сигнал из другого потока. 

**Коллизия** это когда к одному ресурсу сразу обращался несколько потоков…
Что бы этого избежать нужно использовать синхронизацию мютах(он позволяет обращаться к ресурсу только одному потому за раз…) и семафор, либо барьер в GCD
Для Thread мютах использует слова NSLock и далее вызывается переменная.lock и переменная.unlock

**Run Loop** — своего рода бесконечный цикл, предназначенный для обработки и координации всех событий, поступающих к нему на вход.
Когда Run Loop получает сообщение о событии, он запускает обработчик, ассоциированный с этим событием на своем потоке, а после выполнения усыпляет поток до следующего события, именно таким образом приложение узнает о происходящих интерактивных событиях. 

**Атомарная (греч. άτομος — неделимое) операция** — операция, которая либо выполняется целиком, либо не выполняется вовсе; операция, которая не может быть частично выполнена и частично не выполнена.

**Operation** имеет отмену, зависимости, и другие гибкие настройки.
В Swift операция (Operation) это абстракция, используемая для управления параллельными задачами и многозадачностью, особенно в контексте многопоточности и многозадачности. Она является частью фреймворка Foundation и предоставляет удобный способ управления и выполнения задач в фоновом режиме или на разных потоках.
Операции в Swift обычно создаются путем наследования от класса Operation или его подклассов. Вы можете определить свою собственную операцию, переопределяя метод main(), который выполняет фактическую работу операции. Затем операции могут быть добавлены в очередь операций (OperationQueue), которая управляет их выполнением.

Преимущества использования операций в Swift включают в себя:
* Управление зависимостями: Вы можете определить зависимости между операциями, что делает их выполнение более гибким и контролируемым.
* Приоритеты: Операции могут иметь различные приоритеты, что позволяет управлять порядком выполнения задач.
*  Отмена и приостановка: Вы можете отменить или приостановить выполнение операции в любое время.
* Обратная связь: Вы можете использовать операции для обеспечения обратной связи между параллельными задачами.


---

## Диспетчиризация
Вызов метода -> диспетчиризация -> выполнение

Есть три метода диспетчиризации: 
* Static статическая
* Table табличная. Динамическая разделяется еще на два V-table виртуальная  W-table витнес 
* Message сообщения 

**Direct(static)** метод: он быстрый. Но нет полиморфизма и нет наследованная. 
Используется когда метод не может быть переопределен. В расширениях, в final class. И если метод в структуре определен.
Если указать в классе final то все методы станут использовать static метод

**Table W-table** он медленнее static  нет наследованния, но есть полиморфизм.
Используется для реализации методов из протокола.

**Table V-table** он медленнее static  есть наследованния, есть полиморфизм, но затраты на компиляцию.
Используется в классах при наследовании.

**Message** 
Используется в связке с ObjC. 
Самый медленный

По дефолту у структуры статик метод, потому что структура не наследуется, и не предопределяет методы. К классов по дефолту V-Table потому что класс наследуется и может переопределять методы

---

## Keychain

**Keychain** — зашифрованная база данных, куда сохраняются небольшие объемы пользовательской информации.
Keychain в Swift это безопасное хранилище для сохранения конфиденциальных данных, таких как пароли, ключи и другие секреты, на устройствах iOS. Это может быть полезно в приложениях, где важна безопасность пользовательских данных.

У него есть несколько методов: 
* Для удаления используем **SecItemDelete**.
* Для Обновление элемента есть метод SecI****temUpdate.
* Для получения элемента из Keychain-а используется метод **SecItemCopyMatching**.

---

## CALayer and UIView

* **CALayer** компонент для рендеринга визуального содержимого.
* **UIView** контейнер для слоев CALayer который обеспечивает обработке и взаимодействие  с пользователем.

Обработка событий:
* **CALayer** нет средств для обработки событий таких как касание или жесты.
* **UIView** может обрабатывать такие события.

Анимацию лучше делать через **CALayer**, так как он работает через **gpu** а не через процессор, что быстрее и у него более гибкие возможности для создания анимаций.

---

## Render Loop
**Render loop** — это цикл отрисовки в системе iOS.

Жизненный цикл у него такой:
* Получаем событие
* Создаем render tree
* Отправляем на Render Server
* Меняем кадр
    
**Render Server**
Это отдельный процесс, который вызывает методы отрисовки для GPU с использованием OpenGL или Metal. Он отвечает за рендер наших слоев в изображение.

**Offscreen Rendering** по своей сути — это какие-то внеэкранный расчеты.
Под капотом это выглядит следующим образом: во время прорисовки слоя, которому необходима внеэкранные расчеты, GPU останавливает процесс визуализации и передает управление CPU. В свою очередь, CPU выполняет все необходимые операции (например, cоздает тень) и возвращает управление GPU с уже прорисованным слоем. GPU визуализирует его и процесс прорисовки продолжается.

**Frame Buffer** (Буфер кадров): Это основной компонент в графическом рендеринге. Frame Buffer это область памяти, которая представляет собой изображение, которое готово к отображению на экране. 
В iOS, это может быть буфер, в котором хранятся графические данные для отображения на мобильном устройстве.

---

## UIKit элементы

* UILabel: Этот элемент используется для отображения текста на экране.
* UIButton: Кнопка, которая позволяет пользователю выполнять какие-либо действия.
* UITextField: Поле ввода текста, где пользователь может вводить информацию.
* UIImageView: Элемент для отображения изображений.
* UITableView: Табличное представление, используется для отображения данных в виде таблицы.
* UICollectionView: Похож на UITableView, но предоставляет более гибкий способ отображения данных в сетке.
* UITabBar: Панель в нижней части экрана, которая обычно содержит навигационные элементы.
* UINavigationBar: Панель в верхней части экрана, используется для навигации между экранами.
* UISwitch: Переключатель, который позволяет пользователю переключать определенные параметры.
* UIActivityIndicatorView: Индикатор активности, который отображается, когда приложение выполняет какие-либо долгие операции.
* UIProgressView: Индикатор прогресса, используется для отображения процесса выполнения какой-либо операции.
* UITextView: Поле для ввода многострочного текста.
* UISlider: Ползунок, который позволяет пользователю выбирать значение в заданном диапазоне.
* UIStepper: Элемент для увеличения или уменьшения числового значения с заданным шагом.
* UISegmentedControl: Группа взаимосвязанных кнопок, позволяющих пользователю выбирать одну из нескольких опций.
* UIDatePicker: Элемент для выбора даты и времени.
* UIPickerView: Представление для выбора элемента из списка, который может быть прокручиваемым.
* UIAlertController: Интерфейс для отображения всплывающих окон с сообщениями или диалоговыми окнами.
* UIPageControl: Элемент для управления навигацией между страницами или контентом, например, внутри UIScrollView.
* UIToolbar: Панель с кнопками или другими элементами управления, которая может размещаться вверху или внизу экрана.
* UIWebView (устарел): Использовался для отображения веб-содержимого, но теперь рекомендуется использовать WKWebView.
* UIActivityIndicatorView: Индикатор активности, который отображается, когда приложение выполняет какие-либо долгие 
* UIPopoverController (на iPad): Элемент для отображения всплывающих окон или контроллеров.
* UISearchBar: Элемент для добавления строки поиска в интерфейс.
* UIRefreshControl: Элемент для обновления содержимого внутри UIScrollView или UITableView с помощью жеста "потяни, чтобы обновить".
* UIStackView: Контейнер, который упрощает управление расположением и выравниванием других элементов интерфейса.
* UITabBarController: Управляет размещением и навигацией между вкладками в приложении.
* UIVisualEffectView: Позволяет добавлять различные визуальные эффекты к элементам интерфейса.
* UIBlurEffect: Позволяет создавать размытие фона для других элементов интерфейса.

# Алгоритмы

* O(log n)
* O(n)
* O(n log n)
* O(n2)
* O(n!) (n-факториал)

> • Бинарный поиск работает намного быстрее простого.
> • Время выполнения O(log n) быстрее O(n), а с увеличением размера списка, в котором ищется значение, оно становится намного быстрее.
> • Скорость алгоритмов не измеряется в секундах.
> • Время выполнения алгоритма описывается ростом количества операций.
> • Время выполнения алгоритмов выражается как «O-большое».



## Бинарный поиск

> Бинарный поиск — это алгоритм; на входе он получает отсортированный список элементов. Если элемент, который вы ищете, присутствует в списке, то бинарный поиск возвращает ту позицию, в которой он был найден. В противном случае бинарный поиск возвращает null.

Рассмотрим пример того, как работает бинарный поиск. Сыграем в простую игру: я загадал число от 1 до 100. Вы должны отгадать мое число, использовав как можно меньше попыток. При каждой попытке я буду давать один из трех ответов: мало, много или угадал. При каждой догадке исключается только одно число. Если я загадал число 99, то, чтобы добраться до него, потребуется 99 попыток! Существует другой, более эффективный способ. Начнем с 50. Слишком мало… но вы только что исключили половину чисел! Теперь вы знаете, что все числа 1–50 меньше загаданного. Следующая попытка: 75. Так работает бинарный поиск. «Какое бы число я ни задумал, вы гарантированно сможете угадать его не более чем за 7 попыток, потому что с каждой попыткой исключается половина оставшихся чисел!» «В общем случае для списка из n элементов бинарный поиск выполняется за log2n шагов, тогда как простой поиск будет выполнен за n шагов.» «Если список состоит из 100 чисел, может потребоваться до 100 попыток. Для списка из 4 миллиардов чисел потребуется до 4 миллиардов попыток. Таким образом, максимальное количество попыток совпадает с размером списка. Такое время выполнения называется линейным.» «С бинарным поиском дело обстоит иначе. Если список состоит из 100 элементов, потребуется не более 7 попыток. Для списка из 4 миллиардов элементов потребуется не более 32 попыток. Бинарный поиск выполняется за логарифмическое время.

> При бинарном поиске каждый раз исключается половина чисел


«O-большое» определяет время выполнения в худшем случае» Фактически вы утверждаете, что в худшем случае придется просмотреть каждую запись в телефонной книге по одному разу. Это и есть время O(n).





## O-большое
Специальная нотация «O-большое» описывает скорость работы алгоритма. «O-большое» описывает, насколько быстро работает алгоритм. Предположим, имеется список размера n. Простой поиск должен проверить **каждый элемент**, поэтому ему придется выполнить **n операций**. Время выполнения «O-большое» имеет вид **O(n)**. Постойте, но где же секунды? А их здесь нет — «O-большое» не сообщает скорость в секундах, а позволяет сравнить количество операций. Оно указывает, насколько быстро возрастает время выполнения алгоритма. А теперь другой пример. Для проверки списка размером n **бинарному** поиску потребуется log n операций. Как будет выглядеть «O-большое»? **O(log n)**.»

























